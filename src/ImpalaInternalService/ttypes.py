#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Status.ttypes
import Types.ttypes
import Exprs.ttypes
import CatalogObjects.ttypes
import Descriptors.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import DataSinks.ttypes
import Data.ttypes
import RuntimeProfile.ttypes
import ImpalaService.ttypes
import Llama.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TSessionType(object):
  BEESWAX = 0
  HIVESERVER2 = 1

  _VALUES_TO_NAMES = {
    0: "BEESWAX",
    1: "HIVESERVER2",
  }

  _NAMES_TO_VALUES = {
    "BEESWAX": 0,
    "HIVESERVER2": 1,
  }

class ImpalaInternalServiceVersion(object):
  V1 = 0

  _VALUES_TO_NAMES = {
    0: "V1",
  }

  _NAMES_TO_VALUES = {
    "V1": 0,
  }


class TQueryOptions(object):
  """
  Attributes:
   - abort_on_error
   - max_errors
   - disable_codegen
   - batch_size
   - num_nodes
   - max_scan_range_length
   - num_scanner_threads
   - max_io_buffers
   - allow_unsupported_formats
   - default_order_by_limit
   - debug_action
   - mem_limit
   - abort_on_default_limit_exceeded
   - parquet_compression_codec
   - hbase_caching
   - hbase_cache_blocks
   - parquet_file_size
   - explain_level
   - sync_ddl
   - request_pool
   - v_cpu_cores
   - reservation_request_timeout
   - disable_cached_reads
   - disable_outermost_topn
   - rm_initial_mem
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'abort_on_error', None, False, ), # 1
    (2, TType.I32, 'max_errors', None, 0, ), # 2
    (3, TType.BOOL, 'disable_codegen', None, False, ), # 3
    (4, TType.I32, 'batch_size', None, 0, ), # 4
    (5, TType.I32, 'num_nodes', None, 0, ), # 5
    (6, TType.I64, 'max_scan_range_length', None, 0, ), # 6
    (7, TType.I32, 'num_scanner_threads', None, 0, ), # 7
    (8, TType.I32, 'max_io_buffers', None, 0, ), # 8
    (9, TType.BOOL, 'allow_unsupported_formats', None, False, ), # 9
    (10, TType.I64, 'default_order_by_limit', None, -1, ), # 10
    (11, TType.STRING, 'debug_action', None, "", ), # 11
    (12, TType.I64, 'mem_limit', None, 0, ), # 12
    (13, TType.BOOL, 'abort_on_default_limit_exceeded', None, False, ), # 13
    (14, TType.I32, 'parquet_compression_codec', None,     5, ), # 14
    (15, TType.I32, 'hbase_caching', None, 0, ), # 15
    (16, TType.BOOL, 'hbase_cache_blocks', None, False, ), # 16
    (17, TType.I64, 'parquet_file_size', None, 0, ), # 17
    (18, TType.I32, 'explain_level', None,     1, ), # 18
    (19, TType.BOOL, 'sync_ddl', None, False, ), # 19
    (20, TType.STRING, 'request_pool', None, None, ), # 20
    (21, TType.I16, 'v_cpu_cores', None, None, ), # 21
    (22, TType.I64, 'reservation_request_timeout', None, None, ), # 22
    (23, TType.BOOL, 'disable_cached_reads', None, False, ), # 23
    (24, TType.BOOL, 'disable_outermost_topn', None, False, ), # 24
    (25, TType.I64, 'rm_initial_mem', None, 0, ), # 25
  )

  def __init__(self, abort_on_error=thrift_spec[1][4], max_errors=thrift_spec[2][4], disable_codegen=thrift_spec[3][4], batch_size=thrift_spec[4][4], num_nodes=thrift_spec[5][4], max_scan_range_length=thrift_spec[6][4], num_scanner_threads=thrift_spec[7][4], max_io_buffers=thrift_spec[8][4], allow_unsupported_formats=thrift_spec[9][4], default_order_by_limit=thrift_spec[10][4], debug_action=thrift_spec[11][4], mem_limit=thrift_spec[12][4], abort_on_default_limit_exceeded=thrift_spec[13][4], parquet_compression_codec=thrift_spec[14][4], hbase_caching=thrift_spec[15][4], hbase_cache_blocks=thrift_spec[16][4], parquet_file_size=thrift_spec[17][4], explain_level=thrift_spec[18][4], sync_ddl=thrift_spec[19][4], request_pool=None, v_cpu_cores=None, reservation_request_timeout=None, disable_cached_reads=thrift_spec[23][4], disable_outermost_topn=thrift_spec[24][4], rm_initial_mem=thrift_spec[25][4],):
    self.abort_on_error = abort_on_error
    self.max_errors = max_errors
    self.disable_codegen = disable_codegen
    self.batch_size = batch_size
    self.num_nodes = num_nodes
    self.max_scan_range_length = max_scan_range_length
    self.num_scanner_threads = num_scanner_threads
    self.max_io_buffers = max_io_buffers
    self.allow_unsupported_formats = allow_unsupported_formats
    self.default_order_by_limit = default_order_by_limit
    self.debug_action = debug_action
    self.mem_limit = mem_limit
    self.abort_on_default_limit_exceeded = abort_on_default_limit_exceeded
    self.parquet_compression_codec = parquet_compression_codec
    self.hbase_caching = hbase_caching
    self.hbase_cache_blocks = hbase_cache_blocks
    self.parquet_file_size = parquet_file_size
    self.explain_level = explain_level
    self.sync_ddl = sync_ddl
    self.request_pool = request_pool
    self.v_cpu_cores = v_cpu_cores
    self.reservation_request_timeout = reservation_request_timeout
    self.disable_cached_reads = disable_cached_reads
    self.disable_outermost_topn = disable_outermost_topn
    self.rm_initial_mem = rm_initial_mem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.abort_on_error = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max_errors = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.disable_codegen = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.batch_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.num_nodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.max_scan_range_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.num_scanner_threads = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.max_io_buffers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.allow_unsupported_formats = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.default_order_by_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.debug_action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.mem_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.abort_on_default_limit_exceeded = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.parquet_compression_codec = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          self.hbase_caching = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.hbase_cache_blocks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.parquet_file_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.explain_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.sync_ddl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.request_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I16:
          self.v_cpu_cores = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.I64:
          self.reservation_request_timeout = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.BOOL:
          self.disable_cached_reads = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.BOOL:
          self.disable_outermost_topn = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.I64:
          self.rm_initial_mem = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryOptions')
    if self.abort_on_error is not None:
      oprot.writeFieldBegin('abort_on_error', TType.BOOL, 1)
      oprot.writeBool(self.abort_on_error)
      oprot.writeFieldEnd()
    if self.max_errors is not None:
      oprot.writeFieldBegin('max_errors', TType.I32, 2)
      oprot.writeI32(self.max_errors)
      oprot.writeFieldEnd()
    if self.disable_codegen is not None:
      oprot.writeFieldBegin('disable_codegen', TType.BOOL, 3)
      oprot.writeBool(self.disable_codegen)
      oprot.writeFieldEnd()
    if self.batch_size is not None:
      oprot.writeFieldBegin('batch_size', TType.I32, 4)
      oprot.writeI32(self.batch_size)
      oprot.writeFieldEnd()
    if self.num_nodes is not None:
      oprot.writeFieldBegin('num_nodes', TType.I32, 5)
      oprot.writeI32(self.num_nodes)
      oprot.writeFieldEnd()
    if self.max_scan_range_length is not None:
      oprot.writeFieldBegin('max_scan_range_length', TType.I64, 6)
      oprot.writeI64(self.max_scan_range_length)
      oprot.writeFieldEnd()
    if self.num_scanner_threads is not None:
      oprot.writeFieldBegin('num_scanner_threads', TType.I32, 7)
      oprot.writeI32(self.num_scanner_threads)
      oprot.writeFieldEnd()
    if self.max_io_buffers is not None:
      oprot.writeFieldBegin('max_io_buffers', TType.I32, 8)
      oprot.writeI32(self.max_io_buffers)
      oprot.writeFieldEnd()
    if self.allow_unsupported_formats is not None:
      oprot.writeFieldBegin('allow_unsupported_formats', TType.BOOL, 9)
      oprot.writeBool(self.allow_unsupported_formats)
      oprot.writeFieldEnd()
    if self.default_order_by_limit is not None:
      oprot.writeFieldBegin('default_order_by_limit', TType.I64, 10)
      oprot.writeI64(self.default_order_by_limit)
      oprot.writeFieldEnd()
    if self.debug_action is not None:
      oprot.writeFieldBegin('debug_action', TType.STRING, 11)
      oprot.writeString(self.debug_action)
      oprot.writeFieldEnd()
    if self.mem_limit is not None:
      oprot.writeFieldBegin('mem_limit', TType.I64, 12)
      oprot.writeI64(self.mem_limit)
      oprot.writeFieldEnd()
    if self.abort_on_default_limit_exceeded is not None:
      oprot.writeFieldBegin('abort_on_default_limit_exceeded', TType.BOOL, 13)
      oprot.writeBool(self.abort_on_default_limit_exceeded)
      oprot.writeFieldEnd()
    if self.parquet_compression_codec is not None:
      oprot.writeFieldBegin('parquet_compression_codec', TType.I32, 14)
      oprot.writeI32(self.parquet_compression_codec)
      oprot.writeFieldEnd()
    if self.hbase_caching is not None:
      oprot.writeFieldBegin('hbase_caching', TType.I32, 15)
      oprot.writeI32(self.hbase_caching)
      oprot.writeFieldEnd()
    if self.hbase_cache_blocks is not None:
      oprot.writeFieldBegin('hbase_cache_blocks', TType.BOOL, 16)
      oprot.writeBool(self.hbase_cache_blocks)
      oprot.writeFieldEnd()
    if self.parquet_file_size is not None:
      oprot.writeFieldBegin('parquet_file_size', TType.I64, 17)
      oprot.writeI64(self.parquet_file_size)
      oprot.writeFieldEnd()
    if self.explain_level is not None:
      oprot.writeFieldBegin('explain_level', TType.I32, 18)
      oprot.writeI32(self.explain_level)
      oprot.writeFieldEnd()
    if self.sync_ddl is not None:
      oprot.writeFieldBegin('sync_ddl', TType.BOOL, 19)
      oprot.writeBool(self.sync_ddl)
      oprot.writeFieldEnd()
    if self.request_pool is not None:
      oprot.writeFieldBegin('request_pool', TType.STRING, 20)
      oprot.writeString(self.request_pool)
      oprot.writeFieldEnd()
    if self.v_cpu_cores is not None:
      oprot.writeFieldBegin('v_cpu_cores', TType.I16, 21)
      oprot.writeI16(self.v_cpu_cores)
      oprot.writeFieldEnd()
    if self.reservation_request_timeout is not None:
      oprot.writeFieldBegin('reservation_request_timeout', TType.I64, 22)
      oprot.writeI64(self.reservation_request_timeout)
      oprot.writeFieldEnd()
    if self.disable_cached_reads is not None:
      oprot.writeFieldBegin('disable_cached_reads', TType.BOOL, 23)
      oprot.writeBool(self.disable_cached_reads)
      oprot.writeFieldEnd()
    if self.disable_outermost_topn is not None:
      oprot.writeFieldBegin('disable_outermost_topn', TType.BOOL, 24)
      oprot.writeBool(self.disable_outermost_topn)
      oprot.writeFieldEnd()
    if self.rm_initial_mem is not None:
      oprot.writeFieldBegin('rm_initial_mem', TType.I64, 25)
      oprot.writeI64(self.rm_initial_mem)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSessionState(object):
  """
  Attributes:
   - session_id
   - session_type
   - database
   - connected_user
   - delegated_user
   - network_address
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'database', None, None, ), # 1
    (2, TType.STRING, 'connected_user', None, None, ), # 2
    (3, TType.STRUCT, 'session_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'network_address', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 4
    (5, TType.I32, 'session_type', None, None, ), # 5
    (6, TType.STRING, 'delegated_user', None, None, ), # 6
  )

  def __init__(self, session_id=None, session_type=None, database=None, connected_user=None, delegated_user=None, network_address=None,):
    self.session_id = session_id
    self.session_type = session_type
    self.database = database
    self.connected_user = connected_user
    self.delegated_user = delegated_user
    self.network_address = network_address

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.STRUCT:
          self.session_id = Types.ttypes.TUniqueId()
          self.session_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.session_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRING:
          self.database = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.connected_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.delegated_user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.network_address = Types.ttypes.TNetworkAddress()
          self.network_address.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSessionState')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRING, 1)
      oprot.writeString(self.database)
      oprot.writeFieldEnd()
    if self.connected_user is not None:
      oprot.writeFieldBegin('connected_user', TType.STRING, 2)
      oprot.writeString(self.connected_user)
      oprot.writeFieldEnd()
    if self.session_id is not None:
      oprot.writeFieldBegin('session_id', TType.STRUCT, 3)
      self.session_id.write(oprot)
      oprot.writeFieldEnd()
    if self.network_address is not None:
      oprot.writeFieldBegin('network_address', TType.STRUCT, 4)
      self.network_address.write(oprot)
      oprot.writeFieldEnd()
    if self.session_type is not None:
      oprot.writeFieldBegin('session_type', TType.I32, 5)
      oprot.writeI32(self.session_type)
      oprot.writeFieldEnd()
    if self.delegated_user is not None:
      oprot.writeFieldBegin('delegated_user', TType.STRING, 6)
      oprot.writeString(self.delegated_user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.session_id is None:
      raise TProtocol.TProtocolException(message='Required field session_id is unset!')
    if self.session_type is None:
      raise TProtocol.TProtocolException(message='Required field session_type is unset!')
    if self.database is None:
      raise TProtocol.TProtocolException(message='Required field database is unset!')
    if self.connected_user is None:
      raise TProtocol.TProtocolException(message='Required field connected_user is unset!')
    if self.network_address is None:
      raise TProtocol.TProtocolException(message='Required field network_address is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TClientRequest(object):
  """
  Attributes:
   - stmt
   - query_options
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'stmt', None, None, ), # 1
    (2, TType.STRUCT, 'query_options', (TQueryOptions, TQueryOptions.thrift_spec), None, ), # 2
  )

  def __init__(self, stmt=None, query_options=None,):
    self.stmt = stmt
    self.query_options = query_options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_options = TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TClientRequest')
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 1)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt is None:
      raise TProtocol.TProtocolException(message='Required field stmt is unset!')
    if self.query_options is None:
      raise TProtocol.TProtocolException(message='Required field query_options is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryCtx(object):
  """
  Attributes:
   - request
   - query_id
   - session
   - now_string
   - pid
   - coord_address
   - tables_missing_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (TClientRequest, TClientRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'session', (TSessionState, TSessionState.thrift_spec), None, ), # 3
    (4, TType.STRING, 'now_string', None, None, ), # 4
    (5, TType.I32, 'pid', None, None, ), # 5
    (6, TType.STRUCT, 'coord_address', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 6
    (7, TType.LIST, 'tables_missing_stats', (TType.STRUCT,(CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec)), None, ), # 7
  )

  def __init__(self, request=None, query_id=None, session=None, now_string=None, pid=None, coord_address=None, tables_missing_stats=None,):
    self.request = request
    self.query_id = query_id
    self.session = session
    self.now_string = now_string
    self.pid = pid
    self.coord_address = coord_address
    self.tables_missing_stats = tables_missing_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = TClientRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.now_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.pid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.coord_address = Types.ttypes.TNetworkAddress()
          self.coord_address.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.tables_missing_stats = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = CatalogObjects.ttypes.TTableName()
            _elem5.read(iprot)
            self.tables_missing_stats.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryCtx')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.now_string is not None:
      oprot.writeFieldBegin('now_string', TType.STRING, 4)
      oprot.writeString(self.now_string)
      oprot.writeFieldEnd()
    if self.pid is not None:
      oprot.writeFieldBegin('pid', TType.I32, 5)
      oprot.writeI32(self.pid)
      oprot.writeFieldEnd()
    if self.coord_address is not None:
      oprot.writeFieldBegin('coord_address', TType.STRUCT, 6)
      self.coord_address.write(oprot)
      oprot.writeFieldEnd()
    if self.tables_missing_stats is not None:
      oprot.writeFieldBegin('tables_missing_stats', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.tables_missing_stats))
      for iter6 in self.tables_missing_stats:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.request is None:
      raise TProtocol.TProtocolException(message='Required field request is unset!')
    if self.query_id is None:
      raise TProtocol.TProtocolException(message='Required field query_id is unset!')
    if self.session is None:
      raise TProtocol.TProtocolException(message='Required field session is unset!')
    if self.now_string is None:
      raise TProtocol.TProtocolException(message='Required field now_string is unset!')
    if self.pid is None:
      raise TProtocol.TProtocolException(message='Required field pid is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentInstanceCtx(object):
  """
  Attributes:
   - query_ctx
   - fragment_instance_id
   - fragment_instance_idx
   - num_fragment_instances
   - backend_num
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'query_ctx', (TQueryCtx, TQueryCtx.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'fragment_instance_idx', None, None, ), # 3
    (4, TType.I32, 'num_fragment_instances', None, None, ), # 4
    (5, TType.I32, 'backend_num', None, None, ), # 5
  )

  def __init__(self, query_ctx=None, fragment_instance_id=None, fragment_instance_idx=None, num_fragment_instances=None, backend_num=None,):
    self.query_ctx = query_ctx
    self.fragment_instance_id = fragment_instance_id
    self.fragment_instance_idx = fragment_instance_idx
    self.num_fragment_instances = num_fragment_instances
    self.backend_num = backend_num

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.query_ctx = TQueryCtx()
          self.query_ctx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.fragment_instance_idx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.num_fragment_instances = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.backend_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentInstanceCtx')
    if self.query_ctx is not None:
      oprot.writeFieldBegin('query_ctx', TType.STRUCT, 1)
      self.query_ctx.write(oprot)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.fragment_instance_idx is not None:
      oprot.writeFieldBegin('fragment_instance_idx', TType.I32, 3)
      oprot.writeI32(self.fragment_instance_idx)
      oprot.writeFieldEnd()
    if self.num_fragment_instances is not None:
      oprot.writeFieldBegin('num_fragment_instances', TType.I32, 4)
      oprot.writeI32(self.num_fragment_instances)
      oprot.writeFieldEnd()
    if self.backend_num is not None:
      oprot.writeFieldBegin('backend_num', TType.I32, 5)
      oprot.writeI32(self.backend_num)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.query_ctx is None:
      raise TProtocol.TProtocolException(message='Required field query_ctx is unset!')
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.fragment_instance_idx is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_idx is unset!')
    if self.num_fragment_instances is None:
      raise TProtocol.TProtocolException(message='Required field num_fragment_instances is unset!')
    if self.backend_num is None:
      raise TProtocol.TProtocolException(message='Required field backend_num is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRangeParams(object):
  """
  Attributes:
   - scan_range
   - volume_id
   - is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'scan_range', (PlanNodes.ttypes.TScanRange, PlanNodes.ttypes.TScanRange.thrift_spec), None, ), # 1
    (2, TType.I32, 'volume_id', None, -1, ), # 2
    (3, TType.BOOL, 'is_cached', None, False, ), # 3
  )

  def __init__(self, scan_range=None, volume_id=thrift_spec[2][4], is_cached=thrift_spec[3][4],):
    self.scan_range = scan_range
    self.volume_id = volume_id
    self.is_cached = is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.scan_range = PlanNodes.ttypes.TScanRange()
          self.scan_range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volume_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_cached = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRangeParams')
    if self.scan_range is not None:
      oprot.writeFieldBegin('scan_range', TType.STRUCT, 1)
      self.scan_range.write(oprot)
      oprot.writeFieldEnd()
    if self.volume_id is not None:
      oprot.writeFieldBegin('volume_id', TType.I32, 2)
      oprot.writeI32(self.volume_id)
      oprot.writeFieldEnd()
    if self.is_cached is not None:
      oprot.writeFieldBegin('is_cached', TType.BOOL, 3)
      oprot.writeBool(self.is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scan_range is None:
      raise TProtocol.TProtocolException(message='Required field scan_range is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentDestination(object):
  """
  Attributes:
   - fragment_instance_id
   - server
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'server', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 2
  )

  def __init__(self, fragment_instance_id=None, server=None,):
    self.fragment_instance_id = fragment_instance_id
    self.server = server

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.server = Types.ttypes.TNetworkAddress()
          self.server.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentDestination')
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 1)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.server is not None:
      oprot.writeFieldBegin('server', TType.STRUCT, 2)
      self.server.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.server is None:
      raise TProtocol.TProtocolException(message='Required field server is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentExecParams(object):
  """
  Attributes:
   - per_node_scan_ranges
   - per_exch_num_senders
   - destinations
   - debug_node_id
   - debug_phase
   - debug_action
   - request_pool
   - sender_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(TScanRangeParams, TScanRangeParams.thrift_spec))), None, ), # 1
    (2, TType.MAP, 'per_exch_num_senders', (TType.I32,None,TType.I32,None), None, ), # 2
    (3, TType.LIST, 'destinations', (TType.STRUCT,(TPlanFragmentDestination, TPlanFragmentDestination.thrift_spec)), None, ), # 3
    (4, TType.I32, 'debug_node_id', None, None, ), # 4
    (5, TType.I32, 'debug_phase', None, None, ), # 5
    (6, TType.I32, 'debug_action', None, None, ), # 6
    (7, TType.STRING, 'request_pool', None, None, ), # 7
    (8, TType.I32, 'sender_id', None, None, ), # 8
  )

  def __init__(self, per_node_scan_ranges=None, per_exch_num_senders=None, destinations=None, debug_node_id=None, debug_phase=None, debug_action=None, request_pool=None, sender_id=None,):
    self.per_node_scan_ranges = per_node_scan_ranges
    self.per_exch_num_senders = per_exch_num_senders
    self.destinations = destinations
    self.debug_node_id = debug_node_id
    self.debug_phase = debug_phase
    self.debug_action = debug_action
    self.request_pool = request_pool
    self.sender_id = sender_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readI32();
            _val13 = []
            (_etype17, _size14) = iprot.readListBegin()
            for _i18 in xrange(_size14):
              _elem19 = TScanRangeParams()
              _elem19.read(iprot)
              _val13.append(_elem19)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.per_exch_num_senders = {}
          (_ktype21, _vtype22, _size20 ) = iprot.readMapBegin()
          for _i24 in xrange(_size20):
            _key25 = iprot.readI32();
            _val26 = iprot.readI32();
            self.per_exch_num_senders[_key25] = _val26
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.destinations = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = TPlanFragmentDestination()
            _elem32.read(iprot)
            self.destinations.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.debug_node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.debug_phase = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.debug_action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.request_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.sender_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentExecParams')
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter33,viter34 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter33)
        oprot.writeListBegin(TType.STRUCT, len(viter34))
        for iter35 in viter34:
          iter35.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.per_exch_num_senders is not None:
      oprot.writeFieldBegin('per_exch_num_senders', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.per_exch_num_senders))
      for kiter36,viter37 in self.per_exch_num_senders.items():
        oprot.writeI32(kiter36)
        oprot.writeI32(viter37)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.destinations is not None:
      oprot.writeFieldBegin('destinations', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.destinations))
      for iter38 in self.destinations:
        iter38.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.debug_node_id is not None:
      oprot.writeFieldBegin('debug_node_id', TType.I32, 4)
      oprot.writeI32(self.debug_node_id)
      oprot.writeFieldEnd()
    if self.debug_phase is not None:
      oprot.writeFieldBegin('debug_phase', TType.I32, 5)
      oprot.writeI32(self.debug_phase)
      oprot.writeFieldEnd()
    if self.debug_action is not None:
      oprot.writeFieldBegin('debug_action', TType.I32, 6)
      oprot.writeI32(self.debug_action)
      oprot.writeFieldEnd()
    if self.request_pool is not None:
      oprot.writeFieldBegin('request_pool', TType.STRING, 7)
      oprot.writeString(self.request_pool)
      oprot.writeFieldEnd()
    if self.sender_id is not None:
      oprot.writeFieldBegin('sender_id', TType.I32, 8)
      oprot.writeI32(self.sender_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.per_node_scan_ranges is None:
      raise TProtocol.TProtocolException(message='Required field per_node_scan_ranges is unset!')
    if self.per_exch_num_senders is None:
      raise TProtocol.TProtocolException(message='Required field per_exch_num_senders is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecPlanFragmentParams(object):
  """
  Attributes:
   - protocol_version
   - fragment
   - desc_tbl
   - params
   - fragment_instance_ctx
   - reserved_resource
   - local_resource_address
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'fragment', (Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'desc_tbl', (Descriptors.ttypes.TDescriptorTable, Descriptors.ttypes.TDescriptorTable.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'params', (TPlanFragmentExecParams, TPlanFragmentExecParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'fragment_instance_ctx', (TPlanFragmentInstanceCtx, TPlanFragmentInstanceCtx.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'reserved_resource', (Llama.ttypes.TAllocatedResource, Llama.ttypes.TAllocatedResource.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'local_resource_address', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 7
  )

  def __init__(self, protocol_version=None, fragment=None, desc_tbl=None, params=None, fragment_instance_ctx=None, reserved_resource=None, local_resource_address=None,):
    self.protocol_version = protocol_version
    self.fragment = fragment
    self.desc_tbl = desc_tbl
    self.params = params
    self.fragment_instance_ctx = fragment_instance_ctx
    self.reserved_resource = reserved_resource
    self.local_resource_address = local_resource_address

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment = Planner.ttypes.TPlanFragment()
          self.fragment.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.desc_tbl = Descriptors.ttypes.TDescriptorTable()
          self.desc_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.params = TPlanFragmentExecParams()
          self.params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.fragment_instance_ctx = TPlanFragmentInstanceCtx()
          self.fragment_instance_ctx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.reserved_resource = Llama.ttypes.TAllocatedResource()
          self.reserved_resource.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.local_resource_address = Types.ttypes.TNetworkAddress()
          self.local_resource_address.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecPlanFragmentParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.fragment is not None:
      oprot.writeFieldBegin('fragment', TType.STRUCT, 2)
      self.fragment.write(oprot)
      oprot.writeFieldEnd()
    if self.desc_tbl is not None:
      oprot.writeFieldBegin('desc_tbl', TType.STRUCT, 3)
      self.desc_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.STRUCT, 4)
      self.params.write(oprot)
      oprot.writeFieldEnd()
    if self.fragment_instance_ctx is not None:
      oprot.writeFieldBegin('fragment_instance_ctx', TType.STRUCT, 5)
      self.fragment_instance_ctx.write(oprot)
      oprot.writeFieldEnd()
    if self.reserved_resource is not None:
      oprot.writeFieldBegin('reserved_resource', TType.STRUCT, 6)
      self.reserved_resource.write(oprot)
      oprot.writeFieldEnd()
    if self.local_resource_address is not None:
      oprot.writeFieldBegin('local_resource_address', TType.STRUCT, 7)
      self.local_resource_address.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecPlanFragmentResult(object):
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecPlanFragmentResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TParquetInsertStats(object):
  """
  Attributes:
   - per_column_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'per_column_size', (TType.STRING,None,TType.I64,None), None, ), # 1
  )

  def __init__(self, per_column_size=None,):
    self.per_column_size = per_column_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.per_column_size = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin()
          for _i43 in xrange(_size39):
            _key44 = iprot.readString();
            _val45 = iprot.readI64();
            self.per_column_size[_key44] = _val45
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TParquetInsertStats')
    if self.per_column_size is not None:
      oprot.writeFieldBegin('per_column_size', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.per_column_size))
      for kiter46,viter47 in self.per_column_size.items():
        oprot.writeString(kiter46)
        oprot.writeI64(viter47)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.per_column_size is None:
      raise TProtocol.TProtocolException(message='Required field per_column_size is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertStats(object):
  """
  Attributes:
   - bytes_written
   - parquet_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'bytes_written', None, None, ), # 1
    (2, TType.STRUCT, 'parquet_stats', (TParquetInsertStats, TParquetInsertStats.thrift_spec), None, ), # 2
  )

  def __init__(self, bytes_written=None, parquet_stats=None,):
    self.bytes_written = bytes_written
    self.parquet_stats = parquet_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.bytes_written = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.parquet_stats = TParquetInsertStats()
          self.parquet_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertStats')
    if self.bytes_written is not None:
      oprot.writeFieldBegin('bytes_written', TType.I64, 1)
      oprot.writeI64(self.bytes_written)
      oprot.writeFieldEnd()
    if self.parquet_stats is not None:
      oprot.writeFieldBegin('parquet_stats', TType.STRUCT, 2)
      self.parquet_stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.bytes_written is None:
      raise TProtocol.TProtocolException(message='Required field bytes_written is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertPartitionStatus(object):
  """
  Attributes:
   - id
   - num_appended_rows
   - stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'num_appended_rows', None, None, ), # 2
    (3, TType.STRUCT, 'stats', (TInsertStats, TInsertStats.thrift_spec), None, ), # 3
  )

  def __init__(self, id=None, num_appended_rows=None, stats=None,):
    self.id = id
    self.num_appended_rows = num_appended_rows
    self.stats = stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.num_appended_rows = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.stats = TInsertStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertPartitionStatus')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.num_appended_rows is not None:
      oprot.writeFieldBegin('num_appended_rows', TType.I64, 2)
      oprot.writeI64(self.num_appended_rows)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 3)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertExecStatus(object):
  """
  Attributes:
   - files_to_move
   - per_partition_status
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'files_to_move', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.MAP, 'per_partition_status', (TType.STRING,None,TType.STRUCT,(TInsertPartitionStatus, TInsertPartitionStatus.thrift_spec)), None, ), # 2
  )

  def __init__(self, files_to_move=None, per_partition_status=None,):
    self.files_to_move = files_to_move
    self.per_partition_status = per_partition_status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.files_to_move = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin()
          for _i52 in xrange(_size48):
            _key53 = iprot.readString();
            _val54 = iprot.readString();
            self.files_to_move[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.per_partition_status = {}
          (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin()
          for _i59 in xrange(_size55):
            _key60 = iprot.readString();
            _val61 = TInsertPartitionStatus()
            _val61.read(iprot)
            self.per_partition_status[_key60] = _val61
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertExecStatus')
    if self.files_to_move is not None:
      oprot.writeFieldBegin('files_to_move', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.files_to_move))
      for kiter62,viter63 in self.files_to_move.items():
        oprot.writeString(kiter62)
        oprot.writeString(viter63)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.per_partition_status is not None:
      oprot.writeFieldBegin('per_partition_status', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.per_partition_status))
      for kiter64,viter65 in self.per_partition_status.items():
        oprot.writeString(kiter64)
        viter65.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.files_to_move is None:
      raise TProtocol.TProtocolException(message='Required field files_to_move is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusParams(object):
  """
  Attributes:
   - protocol_version
   - query_id
   - backend_num
   - fragment_instance_id
   - status
   - done
   - profile
   - insert_exec_status
   - error_log
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'backend_num', None, None, ), # 3
    (4, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'done', None, None, ), # 6
    (7, TType.STRUCT, 'profile', (RuntimeProfile.ttypes.TRuntimeProfileTree, RuntimeProfile.ttypes.TRuntimeProfileTree.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'insert_exec_status', (TInsertExecStatus, TInsertExecStatus.thrift_spec), None, ), # 8
    (9, TType.LIST, 'error_log', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, protocol_version=None, query_id=None, backend_num=None, fragment_instance_id=None, status=None, done=None, profile=None, insert_exec_status=None, error_log=None,):
    self.protocol_version = protocol_version
    self.query_id = query_id
    self.backend_num = backend_num
    self.fragment_instance_id = fragment_instance_id
    self.status = status
    self.done = done
    self.profile = profile
    self.insert_exec_status = insert_exec_status
    self.error_log = error_log

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.backend_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.done = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.profile = RuntimeProfile.ttypes.TRuntimeProfileTree()
          self.profile.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.insert_exec_status = TInsertExecStatus()
          self.insert_exec_status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.error_log = []
          (_etype69, _size66) = iprot.readListBegin()
          for _i70 in xrange(_size66):
            _elem71 = iprot.readString();
            self.error_log.append(_elem71)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.backend_num is not None:
      oprot.writeFieldBegin('backend_num', TType.I32, 3)
      oprot.writeI32(self.backend_num)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 4)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 5)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.done is not None:
      oprot.writeFieldBegin('done', TType.BOOL, 6)
      oprot.writeBool(self.done)
      oprot.writeFieldEnd()
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRUCT, 7)
      self.profile.write(oprot)
      oprot.writeFieldEnd()
    if self.insert_exec_status is not None:
      oprot.writeFieldBegin('insert_exec_status', TType.STRUCT, 8)
      self.insert_exec_status.write(oprot)
      oprot.writeFieldEnd()
    if self.error_log is not None:
      oprot.writeFieldBegin('error_log', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.error_log))
      for iter72 in self.error_log:
        oprot.writeString(iter72)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusResult(object):
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelPlanFragmentParams(object):
  """
  Attributes:
   - protocol_version
   - fragment_instance_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, protocol_version=None, fragment_instance_id=None,):
    self.protocol_version = protocol_version
    self.fragment_instance_id = fragment_instance_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelPlanFragmentParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelPlanFragmentResult(object):
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelPlanFragmentResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataParams(object):
  """
  Attributes:
   - protocol_version
   - dest_fragment_instance_id
   - sender_id
   - dest_node_id
   - row_batch
   - eos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'dest_fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'sender_id', None, None, ), # 3
    (4, TType.I32, 'dest_node_id', None, None, ), # 4
    (5, TType.STRUCT, 'row_batch', (Data.ttypes.TRowBatch, Data.ttypes.TRowBatch.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'eos', None, None, ), # 6
  )

  def __init__(self, protocol_version=None, dest_fragment_instance_id=None, sender_id=None, dest_node_id=None, row_batch=None, eos=None,):
    self.protocol_version = protocol_version
    self.dest_fragment_instance_id = dest_fragment_instance_id
    self.sender_id = sender_id
    self.dest_node_id = dest_node_id
    self.row_batch = row_batch
    self.eos = eos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dest_fragment_instance_id = Types.ttypes.TUniqueId()
          self.dest_fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.sender_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.dest_node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.row_batch = Data.ttypes.TRowBatch()
          self.row_batch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.eos = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.dest_fragment_instance_id is not None:
      oprot.writeFieldBegin('dest_fragment_instance_id', TType.STRUCT, 2)
      self.dest_fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.sender_id is not None:
      oprot.writeFieldBegin('sender_id', TType.I32, 3)
      oprot.writeI32(self.sender_id)
      oprot.writeFieldEnd()
    if self.dest_node_id is not None:
      oprot.writeFieldBegin('dest_node_id', TType.I32, 4)
      oprot.writeI32(self.dest_node_id)
      oprot.writeFieldEnd()
    if self.row_batch is not None:
      oprot.writeFieldBegin('row_batch', TType.STRUCT, 5)
      self.row_batch.write(oprot)
      oprot.writeFieldEnd()
    if self.eos is not None:
      oprot.writeFieldBegin('eos', TType.BOOL, 6)
      oprot.writeBool(self.eos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataResult(object):
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResolveRequestPoolParams(object):
  """
  Attributes:
   - user
   - requested_pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
    (2, TType.STRING, 'requested_pool', None, None, ), # 2
  )

  def __init__(self, user=None, requested_pool=None,):
    self.user = user
    self.requested_pool = requested_pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.requested_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResolveRequestPoolParams')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.requested_pool is not None:
      oprot.writeFieldBegin('requested_pool', TType.STRING, 2)
      oprot.writeString(self.requested_pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.requested_pool is None:
      raise TProtocol.TProtocolException(message='Required field requested_pool is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResolveRequestPoolResult(object):
  """
  Attributes:
   - resolved_pool
   - has_access
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resolved_pool', None, None, ), # 1
    (2, TType.BOOL, 'has_access', None, None, ), # 2
    (3, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, resolved_pool=None, has_access=None, status=None,):
    self.resolved_pool = resolved_pool
    self.has_access = has_access
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resolved_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_access = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResolveRequestPoolResult')
    if self.resolved_pool is not None:
      oprot.writeFieldBegin('resolved_pool', TType.STRING, 1)
      oprot.writeString(self.resolved_pool)
      oprot.writeFieldEnd()
    if self.has_access is not None:
      oprot.writeFieldBegin('has_access', TType.BOOL, 2)
      oprot.writeBool(self.has_access)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPoolConfigParams(object):
  """
  Attributes:
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool', None, None, ), # 1
  )

  def __init__(self, pool=None,):
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPoolConfigParams')
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.STRING, 1)
      oprot.writeString(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool is None:
      raise TProtocol.TProtocolException(message='Required field pool is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPoolConfigResult(object):
  """
  Attributes:
   - max_requests
   - max_queued
   - mem_limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'max_requests', None, None, ), # 1
    (2, TType.I64, 'max_queued', None, None, ), # 2
    (3, TType.I64, 'mem_limit', None, None, ), # 3
  )

  def __init__(self, max_requests=None, max_queued=None, mem_limit=None,):
    self.max_requests = max_requests
    self.max_queued = max_queued
    self.mem_limit = mem_limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.max_requests = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max_queued = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mem_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPoolConfigResult')
    if self.max_requests is not None:
      oprot.writeFieldBegin('max_requests', TType.I64, 1)
      oprot.writeI64(self.max_requests)
      oprot.writeFieldEnd()
    if self.max_queued is not None:
      oprot.writeFieldBegin('max_queued', TType.I64, 2)
      oprot.writeI64(self.max_queued)
      oprot.writeFieldEnd()
    if self.mem_limit is not None:
      oprot.writeFieldBegin('mem_limit', TType.I64, 3)
      oprot.writeI64(self.mem_limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.max_requests is None:
      raise TProtocol.TProtocolException(message='Required field max_requests is unset!')
    if self.max_queued is None:
      raise TProtocol.TProtocolException(message='Required field max_queued is unset!')
    if self.mem_limit is None:
      raise TProtocol.TProtocolException(message='Required field mem_limit is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
