#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import CatalogObjects.ttypes
import Types.ttypes
import Status.ttypes
import cli_service.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TDdlType(object):
  ALTER_TABLE = 0
  ALTER_VIEW = 1
  CREATE_DATABASE = 2
  CREATE_TABLE = 3
  CREATE_TABLE_AS_SELECT = 4
  CREATE_TABLE_LIKE = 5
  CREATE_VIEW = 6
  CREATE_FUNCTION = 7
  COMPUTE_STATS = 8
  DROP_DATABASE = 9
  DROP_TABLE = 10
  DROP_VIEW = 11
  DROP_FUNCTION = 12
  CREATE_DATA_SOURCE = 13
  DROP_DATA_SOURCE = 14
  DROP_STATS = 15

  _VALUES_TO_NAMES = {
    0: "ALTER_TABLE",
    1: "ALTER_VIEW",
    2: "CREATE_DATABASE",
    3: "CREATE_TABLE",
    4: "CREATE_TABLE_AS_SELECT",
    5: "CREATE_TABLE_LIKE",
    6: "CREATE_VIEW",
    7: "CREATE_FUNCTION",
    8: "COMPUTE_STATS",
    9: "DROP_DATABASE",
    10: "DROP_TABLE",
    11: "DROP_VIEW",
    12: "DROP_FUNCTION",
    13: "CREATE_DATA_SOURCE",
    14: "DROP_DATA_SOURCE",
    15: "DROP_STATS",
  }

  _NAMES_TO_VALUES = {
    "ALTER_TABLE": 0,
    "ALTER_VIEW": 1,
    "CREATE_DATABASE": 2,
    "CREATE_TABLE": 3,
    "CREATE_TABLE_AS_SELECT": 4,
    "CREATE_TABLE_LIKE": 5,
    "CREATE_VIEW": 6,
    "CREATE_FUNCTION": 7,
    "COMPUTE_STATS": 8,
    "DROP_DATABASE": 9,
    "DROP_TABLE": 10,
    "DROP_VIEW": 11,
    "DROP_FUNCTION": 12,
    "CREATE_DATA_SOURCE": 13,
    "DROP_DATA_SOURCE": 14,
    "DROP_STATS": 15,
  }

class TAlterTableType(object):
  ADD_REPLACE_COLUMNS = 0
  ADD_PARTITION = 1
  CHANGE_COLUMN = 2
  DROP_COLUMN = 3
  DROP_PARTITION = 4
  RENAME_TABLE = 5
  RENAME_VIEW = 6
  SET_FILE_FORMAT = 7
  SET_LOCATION = 8
  SET_TBL_PROPERTIES = 9
  UPDATE_STATS = 10
  SET_CACHED = 11

  _VALUES_TO_NAMES = {
    0: "ADD_REPLACE_COLUMNS",
    1: "ADD_PARTITION",
    2: "CHANGE_COLUMN",
    3: "DROP_COLUMN",
    4: "DROP_PARTITION",
    5: "RENAME_TABLE",
    6: "RENAME_VIEW",
    7: "SET_FILE_FORMAT",
    8: "SET_LOCATION",
    9: "SET_TBL_PROPERTIES",
    10: "UPDATE_STATS",
    11: "SET_CACHED",
  }

  _NAMES_TO_VALUES = {
    "ADD_REPLACE_COLUMNS": 0,
    "ADD_PARTITION": 1,
    "CHANGE_COLUMN": 2,
    "DROP_COLUMN": 3,
    "DROP_PARTITION": 4,
    "RENAME_TABLE": 5,
    "RENAME_VIEW": 6,
    "SET_FILE_FORMAT": 7,
    "SET_LOCATION": 8,
    "SET_TBL_PROPERTIES": 9,
    "UPDATE_STATS": 10,
    "SET_CACHED": 11,
  }


class TCreateDbParams(object):
  """
  Attributes:
   - db
   - comment
   - location
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
    (3, TType.STRING, 'location', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
  )

  def __init__(self, db=None, comment=None, location=None, if_not_exists=None,):
    self.db = db
    self.comment = comment
    self.location = location
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 3)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateDataSourceParams(object):
  """
  Attributes:
   - data_source
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data_source', (CatalogObjects.ttypes.TDataSource, CatalogObjects.ttypes.TDataSource.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ), # 2
  )

  def __init__(self, data_source=None, if_not_exists=None,):
    self.data_source = data_source
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data_source = CatalogObjects.ttypes.TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDataSourceParams')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropDataSourceParams(object):
  """
  Attributes:
   - data_source
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data_source', None, None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, data_source=None, if_exists=None,):
    self.data_source = data_source
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data_source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropDataSourceParams')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRING, 1)
      oprot.writeString(self.data_source)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropStatsParams(object):
  """
  Attributes:
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
  )

  def __init__(self, table_name=None,):
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateFunctionParams(object):
  """
  Attributes:
   - fn
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ), # 2
  )

  def __init__(self, fn=None, if_not_exists=None,):
    self.fn = fn
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateFunctionParams')
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 1)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn is None:
      raise TProtocol.TProtocolException(message='Required field fn is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableRowFormat(object):
  """
  Attributes:
   - field_terminator
   - line_terminator
   - escaped_by
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field_terminator', None, None, ), # 1
    (2, TType.STRING, 'line_terminator', None, None, ), # 2
    (3, TType.STRING, 'escaped_by', None, None, ), # 3
  )

  def __init__(self, field_terminator=None, line_terminator=None, escaped_by=None,):
    self.field_terminator = field_terminator
    self.line_terminator = line_terminator
    self.escaped_by = escaped_by

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.line_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.escaped_by = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableRowFormat')
    if self.field_terminator is not None:
      oprot.writeFieldBegin('field_terminator', TType.STRING, 1)
      oprot.writeString(self.field_terminator)
      oprot.writeFieldEnd()
    if self.line_terminator is not None:
      oprot.writeFieldBegin('line_terminator', TType.STRING, 2)
      oprot.writeString(self.line_terminator)
      oprot.writeFieldEnd()
    if self.escaped_by is not None:
      oprot.writeFieldBegin('escaped_by', TType.STRING, 3)
      oprot.writeString(self.escaped_by)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsCachingOp(object):
  """
  Attributes:
   - set_cached
   - cache_pool_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'set_cached', None, None, ), # 1
    (2, TType.STRING, 'cache_pool_name', None, None, ), # 2
  )

  def __init__(self, set_cached=None, cache_pool_name=None,):
    self.set_cached = set_cached
    self.cache_pool_name = cache_pool_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.set_cached = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.cache_pool_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsCachingOp')
    if self.set_cached is not None:
      oprot.writeFieldBegin('set_cached', TType.BOOL, 1)
      oprot.writeBool(self.set_cached)
      oprot.writeFieldEnd()
    if self.cache_pool_name is not None:
      oprot.writeFieldBegin('cache_pool_name', TType.STRING, 2)
      oprot.writeString(self.cache_pool_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.set_cached is None:
      raise TProtocol.TProtocolException(message='Required field set_cached is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableOrViewRenameParams(object):
  """
  Attributes:
   - new_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
  )

  def __init__(self, new_table_name=None,):
    self.new_table_name = new_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_table_name = CatalogObjects.ttypes.TTableName()
          self.new_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableOrViewRenameParams')
    if self.new_table_name is not None:
      oprot.writeFieldBegin('new_table_name', TType.STRUCT, 1)
      self.new_table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.new_table_name is None:
      raise TProtocol.TProtocolException(message='Required field new_table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddReplaceColsParams(object):
  """
  Attributes:
   - columns
   - replace_existing_cols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'replace_existing_cols', None, None, ), # 2
  )

  def __init__(self, columns=None, replace_existing_cols=None,):
    self.columns = columns
    self.replace_existing_cols = replace_existing_cols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = CatalogObjects.ttypes.TColumn()
            _elem5.read(iprot)
            self.columns.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.replace_existing_cols = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddReplaceColsParams')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter6 in self.columns:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.replace_existing_cols is not None:
      oprot.writeFieldBegin('replace_existing_cols', TType.BOOL, 2)
      oprot.writeBool(self.replace_existing_cols)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.replace_existing_cols is None:
      raise TProtocol.TProtocolException(message='Required field replace_existing_cols is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddPartitionParams(object):
  """
  Attributes:
   - partition_spec
   - if_not_exists
   - location
   - cache_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.BOOL, 'if_not_exists', None, None, ), # 3
    (4, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 4
  )

  def __init__(self, partition_spec=None, if_not_exists=None, location=None, cache_op=None,):
    self.partition_spec = partition_spec
    self.if_not_exists = if_not_exists
    self.location = location
    self.cache_op = cache_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem12.read(iprot)
            self.partition_spec.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddPartitionParams')
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter13 in self.partition_spec:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 4)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field partition_spec is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropColParams(object):
  """
  Attributes:
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
  )

  def __init__(self, col_name=None,):
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropPartitionParams(object):
  """
  Attributes:
   - partition_spec
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, partition_spec=None, if_exists=None,):
    self.partition_spec = partition_spec
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem19.read(iprot)
            self.partition_spec.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropPartitionParams')
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter20 in self.partition_spec:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field partition_spec is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableChangeColParams(object):
  """
  Attributes:
   - col_name
   - new_col_def
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
    (2, TType.STRUCT, 'new_col_def', (CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec), None, ), # 2
  )

  def __init__(self, col_name=None, new_col_def=None,):
    self.col_name = col_name
    self.new_col_def = new_col_def

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.new_col_def = CatalogObjects.ttypes.TColumn()
          self.new_col_def.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableChangeColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    if self.new_col_def is not None:
      oprot.writeFieldBegin('new_col_def', TType.STRUCT, 2)
      self.new_col_def.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    if self.new_col_def is None:
      raise TProtocol.TProtocolException(message='Required field new_col_def is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetTblPropertiesParams(object):
  """
  Attributes:
   - target
   - properties
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'target', None, None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 3
  )

  def __init__(self, target=None, properties=None, partition_spec=None,):
    self.target = target
    self.properties = properties
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.target = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString();
            _val27 = iprot.readString();
            self.properties[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem33.read(iprot)
            self.partition_spec.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetTblPropertiesParams')
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.I32, 1)
      oprot.writeI32(self.target)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter34,viter35 in self.properties.items():
        oprot.writeString(kiter34)
        oprot.writeString(viter35)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter36 in self.partition_spec:
        iter36.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.target is None:
      raise TProtocol.TProtocolException(message='Required field target is unset!')
    if self.properties is None:
      raise TProtocol.TProtocolException(message='Required field properties is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetFileFormatParams(object):
  """
  Attributes:
   - file_format
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'file_format', None, None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, file_format=None, partition_spec=None,):
    self.file_format = file_format
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem42.read(iprot)
            self.partition_spec.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetFileFormatParams')
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 1)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter43 in self.partition_spec:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetLocationParams(object):
  """
  Attributes:
   - location
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'location', None, None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, location=None, partition_spec=None,):
    self.location = location
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem49.read(iprot)
            self.partition_spec.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetLocationParams')
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 1)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter50 in self.partition_spec:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableUpdateStatsParams(object):
  """
  Attributes:
   - table_name
   - table_stats
   - partition_stats
   - column_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'table_stats', (CatalogObjects.ttypes.TTableStats, CatalogObjects.ttypes.TTableStats.thrift_spec), None, ), # 2
    (3, TType.MAP, 'partition_stats', (TType.LIST,(TType.STRING,None),TType.STRUCT,(CatalogObjects.ttypes.TTableStats, CatalogObjects.ttypes.TTableStats.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'column_stats', (TType.STRING,None,TType.STRUCT,(CatalogObjects.ttypes.TColumnStats, CatalogObjects.ttypes.TColumnStats.thrift_spec)), None, ), # 4
  )

  def __init__(self, table_name=None, table_stats=None, partition_stats=None, column_stats=None,):
    self.table_name = table_name
    self.table_stats = table_stats
    self.partition_stats = partition_stats
    self.column_stats = column_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_stats = CatalogObjects.ttypes.TTableStats()
          self.table_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.partition_stats = {}
          (_ktype52, _vtype53, _size51 ) = iprot.readMapBegin()
          for _i55 in xrange(_size51):
            _key56 = []
            (_etype61, _size58) = iprot.readListBegin()
            for _i62 in xrange(_size58):
              _elem63 = iprot.readString();
              _key56.append(_elem63)
            iprot.readListEnd()
            _val57 = CatalogObjects.ttypes.TTableStats()
            _val57.read(iprot)
            self.partition_stats[_key56] = _val57
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.column_stats = {}
          (_ktype65, _vtype66, _size64 ) = iprot.readMapBegin()
          for _i68 in xrange(_size64):
            _key69 = iprot.readString();
            _val70 = CatalogObjects.ttypes.TColumnStats()
            _val70.read(iprot)
            self.column_stats[_key69] = _val70
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableUpdateStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.table_stats is not None:
      oprot.writeFieldBegin('table_stats', TType.STRUCT, 2)
      self.table_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_stats is not None:
      oprot.writeFieldBegin('partition_stats', TType.MAP, 3)
      oprot.writeMapBegin(TType.LIST, TType.STRUCT, len(self.partition_stats))
      for kiter71,viter72 in self.partition_stats.items():
        oprot.writeListBegin(TType.STRING, len(kiter71))
        for iter73 in kiter71:
          oprot.writeString(iter73)
        oprot.writeListEnd()
        viter72.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.column_stats is not None:
      oprot.writeFieldBegin('column_stats', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.column_stats))
      for kiter74,viter75 in self.column_stats.items():
        oprot.writeString(kiter74)
        viter75.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetCachedParams(object):
  """
  Attributes:
   - cache_op
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, cache_op=None, partition_spec=None,):
    self.cache_op = cache_op
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem81.read(iprot)
            self.partition_spec.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetCachedParams')
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 1)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter82 in self.partition_spec:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cache_op is None:
      raise TProtocol.TProtocolException(message='Required field cache_op is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableParams(object):
  """
  Attributes:
   - alter_type
   - table_name
   - rename_params
   - add_replace_cols_params
   - add_partition_params
   - change_col_params
   - drop_col_params
   - drop_partition_params
   - set_file_format_params
   - set_location_params
   - set_tbl_properties_params
   - update_stats_params
   - set_cached_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'alter_type', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'rename_params', (TAlterTableOrViewRenameParams, TAlterTableOrViewRenameParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'add_replace_cols_params', (TAlterTableAddReplaceColsParams, TAlterTableAddReplaceColsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'add_partition_params', (TAlterTableAddPartitionParams, TAlterTableAddPartitionParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'change_col_params', (TAlterTableChangeColParams, TAlterTableChangeColParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'drop_col_params', (TAlterTableDropColParams, TAlterTableDropColParams.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'drop_partition_params', (TAlterTableDropPartitionParams, TAlterTableDropPartitionParams.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'set_file_format_params', (TAlterTableSetFileFormatParams, TAlterTableSetFileFormatParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'set_location_params', (TAlterTableSetLocationParams, TAlterTableSetLocationParams.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'set_tbl_properties_params', (TAlterTableSetTblPropertiesParams, TAlterTableSetTblPropertiesParams.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'update_stats_params', (TAlterTableUpdateStatsParams, TAlterTableUpdateStatsParams.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'set_cached_params', (TAlterTableSetCachedParams, TAlterTableSetCachedParams.thrift_spec), None, ), # 13
  )

  def __init__(self, alter_type=None, table_name=None, rename_params=None, add_replace_cols_params=None, add_partition_params=None, change_col_params=None, drop_col_params=None, drop_partition_params=None, set_file_format_params=None, set_location_params=None, set_tbl_properties_params=None, update_stats_params=None, set_cached_params=None,):
    self.alter_type = alter_type
    self.table_name = table_name
    self.rename_params = rename_params
    self.add_replace_cols_params = add_replace_cols_params
    self.add_partition_params = add_partition_params
    self.change_col_params = change_col_params
    self.drop_col_params = drop_col_params
    self.drop_partition_params = drop_partition_params
    self.set_file_format_params = set_file_format_params
    self.set_location_params = set_location_params
    self.set_tbl_properties_params = set_tbl_properties_params
    self.update_stats_params = update_stats_params
    self.set_cached_params = set_cached_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.alter_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rename_params = TAlterTableOrViewRenameParams()
          self.rename_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.add_replace_cols_params = TAlterTableAddReplaceColsParams()
          self.add_replace_cols_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.add_partition_params = TAlterTableAddPartitionParams()
          self.add_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.change_col_params = TAlterTableChangeColParams()
          self.change_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.drop_col_params = TAlterTableDropColParams()
          self.drop_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.drop_partition_params = TAlterTableDropPartitionParams()
          self.drop_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.set_file_format_params = TAlterTableSetFileFormatParams()
          self.set_file_format_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.set_location_params = TAlterTableSetLocationParams()
          self.set_location_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.set_tbl_properties_params = TAlterTableSetTblPropertiesParams()
          self.set_tbl_properties_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.update_stats_params = TAlterTableUpdateStatsParams()
          self.update_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.set_cached_params = TAlterTableSetCachedParams()
          self.set_cached_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableParams')
    if self.alter_type is not None:
      oprot.writeFieldBegin('alter_type', TType.I32, 1)
      oprot.writeI32(self.alter_type)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.rename_params is not None:
      oprot.writeFieldBegin('rename_params', TType.STRUCT, 3)
      self.rename_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_replace_cols_params is not None:
      oprot.writeFieldBegin('add_replace_cols_params', TType.STRUCT, 4)
      self.add_replace_cols_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_partition_params is not None:
      oprot.writeFieldBegin('add_partition_params', TType.STRUCT, 5)
      self.add_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.change_col_params is not None:
      oprot.writeFieldBegin('change_col_params', TType.STRUCT, 6)
      self.change_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_col_params is not None:
      oprot.writeFieldBegin('drop_col_params', TType.STRUCT, 7)
      self.drop_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_partition_params is not None:
      oprot.writeFieldBegin('drop_partition_params', TType.STRUCT, 8)
      self.drop_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_file_format_params is not None:
      oprot.writeFieldBegin('set_file_format_params', TType.STRUCT, 9)
      self.set_file_format_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_location_params is not None:
      oprot.writeFieldBegin('set_location_params', TType.STRUCT, 10)
      self.set_location_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_tbl_properties_params is not None:
      oprot.writeFieldBegin('set_tbl_properties_params', TType.STRUCT, 11)
      self.set_tbl_properties_params.write(oprot)
      oprot.writeFieldEnd()
    if self.update_stats_params is not None:
      oprot.writeFieldBegin('update_stats_params', TType.STRUCT, 12)
      self.update_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_cached_params is not None:
      oprot.writeFieldBegin('set_cached_params', TType.STRUCT, 13)
      self.set_cached_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.alter_type is None:
      raise TProtocol.TProtocolException(message='Required field alter_type is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableLikeParams(object):
  """
  Attributes:
   - table_name
   - src_table_name
   - is_external
   - if_not_exists
   - owner
   - file_format
   - comment
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'src_table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_external', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
    (5, TType.STRING, 'owner', None, None, ), # 5
    (6, TType.I32, 'file_format', None, None, ), # 6
    (7, TType.STRING, 'comment', None, None, ), # 7
    (8, TType.STRING, 'location', None, None, ), # 8
  )

  def __init__(self, table_name=None, src_table_name=None, is_external=None, if_not_exists=None, owner=None, file_format=None, comment=None, location=None,):
    self.table_name = table_name
    self.src_table_name = src_table_name
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.owner = owner
    self.file_format = file_format
    self.comment = comment
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.src_table_name = CatalogObjects.ttypes.TTableName()
          self.src_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableLikeParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.src_table_name is not None:
      oprot.writeFieldBegin('src_table_name', TType.STRUCT, 2)
      self.src_table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 3)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 5)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 6)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 7)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 8)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.src_table_name is None:
      raise TProtocol.TProtocolException(message='Required field src_table_name is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableParams(object):
  """
  Attributes:
   - table_name
   - columns
   - partition_columns
   - file_format
   - is_external
   - if_not_exists
   - owner
   - row_format
   - comment
   - location
   - table_properties
   - serde_properties
   - cache_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'partition_columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 3
    (4, TType.I32, 'file_format', None, None, ), # 4
    (5, TType.BOOL, 'is_external', None, None, ), # 5
    (6, TType.BOOL, 'if_not_exists', None, None, ), # 6
    (7, TType.STRING, 'owner', None, None, ), # 7
    (8, TType.STRUCT, 'row_format', (TTableRowFormat, TTableRowFormat.thrift_spec), None, ), # 8
    (9, TType.STRING, 'comment', None, None, ), # 9
    (10, TType.STRING, 'location', None, None, ), # 10
    (11, TType.MAP, 'table_properties', (TType.STRING,None,TType.STRING,None), None, ), # 11
    (12, TType.MAP, 'serde_properties', (TType.STRING,None,TType.STRING,None), None, ), # 12
    (13, TType.STRUCT, 'cache_op', (THdfsCachingOp, THdfsCachingOp.thrift_spec), None, ), # 13
  )

  def __init__(self, table_name=None, columns=None, partition_columns=None, file_format=None, is_external=None, if_not_exists=None, owner=None, row_format=None, comment=None, location=None, table_properties=None, serde_properties=None, cache_op=None,):
    self.table_name = table_name
    self.columns = columns
    self.partition_columns = partition_columns
    self.file_format = file_format
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.owner = owner
    self.row_format = row_format
    self.comment = comment
    self.location = location
    self.table_properties = table_properties
    self.serde_properties = serde_properties
    self.cache_op = cache_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = CatalogObjects.ttypes.TColumn()
            _elem88.read(iprot)
            self.columns.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partition_columns = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = CatalogObjects.ttypes.TColumn()
            _elem94.read(iprot)
            self.partition_columns.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.row_format = TTableRowFormat()
          self.row_format.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.table_properties = {}
          (_ktype96, _vtype97, _size95 ) = iprot.readMapBegin()
          for _i99 in xrange(_size95):
            _key100 = iprot.readString();
            _val101 = iprot.readString();
            self.table_properties[_key100] = _val101
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.serde_properties = {}
          (_ktype103, _vtype104, _size102 ) = iprot.readMapBegin()
          for _i106 in xrange(_size102):
            _key107 = iprot.readString();
            _val108 = iprot.readString();
            self.serde_properties[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.cache_op = THdfsCachingOp()
          self.cache_op.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter109 in self.columns:
        iter109.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_columns is not None:
      oprot.writeFieldBegin('partition_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_columns))
      for iter110 in self.partition_columns:
        iter110.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 4)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 5)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 6)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 7)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.row_format is not None:
      oprot.writeFieldBegin('row_format', TType.STRUCT, 8)
      self.row_format.write(oprot)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 9)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 10)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.table_properties is not None:
      oprot.writeFieldBegin('table_properties', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.table_properties))
      for kiter111,viter112 in self.table_properties.items():
        oprot.writeString(kiter111)
        oprot.writeString(viter112)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.serde_properties is not None:
      oprot.writeFieldBegin('serde_properties', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.serde_properties))
      for kiter113,viter114 in self.serde_properties.items():
        oprot.writeString(kiter113)
        oprot.writeString(viter114)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.cache_op is not None:
      oprot.writeFieldBegin('cache_op', TType.STRUCT, 13)
      self.cache_op.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateOrAlterViewParams(object):
  """
  Attributes:
   - view_name
   - columns
   - owner
   - original_view_def
   - expanded_view_def
   - comment
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'view_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(CatalogObjects.ttypes.TColumn, CatalogObjects.ttypes.TColumn.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.STRING, 'original_view_def', None, None, ), # 4
    (5, TType.STRING, 'expanded_view_def', None, None, ), # 5
    (6, TType.STRING, 'comment', None, None, ), # 6
    (7, TType.BOOL, 'if_not_exists', None, None, ), # 7
  )

  def __init__(self, view_name=None, columns=None, owner=None, original_view_def=None, expanded_view_def=None, comment=None, if_not_exists=None,):
    self.view_name = view_name
    self.columns = columns
    self.owner = owner
    self.original_view_def = original_view_def
    self.expanded_view_def = expanded_view_def
    self.comment = comment
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.view_name = CatalogObjects.ttypes.TTableName()
          self.view_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype118, _size115) = iprot.readListBegin()
          for _i119 in xrange(_size115):
            _elem120 = CatalogObjects.ttypes.TColumn()
            _elem120.read(iprot)
            self.columns.append(_elem120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.original_view_def = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.expanded_view_def = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateOrAlterViewParams')
    if self.view_name is not None:
      oprot.writeFieldBegin('view_name', TType.STRUCT, 1)
      self.view_name.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter121 in self.columns:
        iter121.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.original_view_def is not None:
      oprot.writeFieldBegin('original_view_def', TType.STRING, 4)
      oprot.writeString(self.original_view_def)
      oprot.writeFieldEnd()
    if self.expanded_view_def is not None:
      oprot.writeFieldBegin('expanded_view_def', TType.STRING, 5)
      oprot.writeString(self.expanded_view_def)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 6)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 7)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.view_name is None:
      raise TProtocol.TProtocolException(message='Required field view_name is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.owner is None:
      raise TProtocol.TProtocolException(message='Required field owner is unset!')
    if self.original_view_def is None:
      raise TProtocol.TProtocolException(message='Required field original_view_def is unset!')
    if self.expanded_view_def is None:
      raise TProtocol.TProtocolException(message='Required field expanded_view_def is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TComputeStatsParams(object):
  """
  Attributes:
   - table_name
   - tbl_stats_query
   - col_stats_query
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRING, 'tbl_stats_query', None, None, ), # 2
    (3, TType.STRING, 'col_stats_query', None, None, ), # 3
  )

  def __init__(self, table_name=None, tbl_stats_query=None, col_stats_query=None,):
    self.table_name = table_name
    self.tbl_stats_query = tbl_stats_query
    self.col_stats_query = col_stats_query

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_stats_query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_stats_query = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TComputeStatsParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl_stats_query is not None:
      oprot.writeFieldBegin('tbl_stats_query', TType.STRING, 2)
      oprot.writeString(self.tbl_stats_query)
      oprot.writeFieldEnd()
    if self.col_stats_query is not None:
      oprot.writeFieldBegin('col_stats_query', TType.STRING, 3)
      oprot.writeString(self.col_stats_query)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.tbl_stats_query is None:
      raise TProtocol.TProtocolException(message='Required field tbl_stats_query is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropDbParams(object):
  """
  Attributes:
   - db
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, db=None, if_exists=None,):
    self.db = db
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropTableOrViewParams(object):
  """
  Attributes:
   - table_name
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, table_name=None, if_exists=None,):
    self.table_name = table_name
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropTableOrViewParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropFunctionParams(object):
  """
  Attributes:
   - fn_name
   - arg_types
   - if_exists
   - signature
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn_name', (Types.ttypes.TFunctionName, Types.ttypes.TFunctionName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'arg_types', (TType.STRUCT,(Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec)), None, ), # 2
    (3, TType.BOOL, 'if_exists', None, None, ), # 3
    (4, TType.STRING, 'signature', None, None, ), # 4
  )

  def __init__(self, fn_name=None, arg_types=None, if_exists=None, signature=None,):
    self.fn_name = fn_name
    self.arg_types = arg_types
    self.if_exists = if_exists
    self.signature = signature

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn_name = Types.ttypes.TFunctionName()
          self.fn_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.arg_types = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in xrange(_size122):
            _elem127 = Types.ttypes.TColumnType()
            _elem127.read(iprot)
            self.arg_types.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.signature = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropFunctionParams')
    if self.fn_name is not None:
      oprot.writeFieldBegin('fn_name', TType.STRUCT, 1)
      self.fn_name.write(oprot)
      oprot.writeFieldEnd()
    if self.arg_types is not None:
      oprot.writeFieldBegin('arg_types', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
      for iter128 in self.arg_types:
        iter128.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    if self.signature is not None:
      oprot.writeFieldBegin('signature', TType.STRING, 4)
      oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn_name is None:
      raise TProtocol.TProtocolException(message='Required field fn_name is unset!')
    if self.arg_types is None:
      raise TProtocol.TProtocolException(message='Required field arg_types is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
