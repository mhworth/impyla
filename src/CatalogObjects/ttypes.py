#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Exprs.ttypes
import Status.ttypes
import Types.ttypes
import hive_metastore.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TCatalogObjectType(object):
  UNKNOWN = 0
  CATALOG = 1
  DATABASE = 2
  TABLE = 3
  VIEW = 4
  FUNCTION = 5
  DATA_SOURCE = 6
  ROLE = 7
  PRIVILEGE = 8
  HDFS_CACHE_POOL = 9

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "CATALOG",
    2: "DATABASE",
    3: "TABLE",
    4: "VIEW",
    5: "FUNCTION",
    6: "DATA_SOURCE",
    7: "ROLE",
    8: "PRIVILEGE",
    9: "HDFS_CACHE_POOL",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "CATALOG": 1,
    "DATABASE": 2,
    "TABLE": 3,
    "VIEW": 4,
    "FUNCTION": 5,
    "DATA_SOURCE": 6,
    "ROLE": 7,
    "PRIVILEGE": 8,
    "HDFS_CACHE_POOL": 9,
  }

class TTableType(object):
  HDFS_TABLE = 0
  HBASE_TABLE = 1
  VIEW = 2
  DATA_SOURCE_TABLE = 3

  _VALUES_TO_NAMES = {
    0: "HDFS_TABLE",
    1: "HBASE_TABLE",
    2: "VIEW",
    3: "DATA_SOURCE_TABLE",
  }

  _NAMES_TO_VALUES = {
    "HDFS_TABLE": 0,
    "HBASE_TABLE": 1,
    "VIEW": 2,
    "DATA_SOURCE_TABLE": 3,
  }

class THdfsFileFormat(object):
  TEXT = 0
  LZO_TEXT = 1
  RC_FILE = 2
  SEQUENCE_FILE = 3
  AVRO = 4
  PARQUET = 5

  _VALUES_TO_NAMES = {
    0: "TEXT",
    1: "LZO_TEXT",
    2: "RC_FILE",
    3: "SEQUENCE_FILE",
    4: "AVRO",
    5: "PARQUET",
  }

  _NAMES_TO_VALUES = {
    "TEXT": 0,
    "LZO_TEXT": 1,
    "RC_FILE": 2,
    "SEQUENCE_FILE": 3,
    "AVRO": 4,
    "PARQUET": 5,
  }

class THdfsCompression(object):
  NONE = 0
  DEFAULT = 1
  GZIP = 2
  DEFLATE = 3
  BZIP2 = 4
  SNAPPY = 5
  SNAPPY_BLOCKED = 6
  LZO = 7
  LZ4 = 8

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "DEFAULT",
    2: "GZIP",
    3: "DEFLATE",
    4: "BZIP2",
    5: "SNAPPY",
    6: "SNAPPY_BLOCKED",
    7: "LZO",
    8: "LZ4",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "DEFAULT": 1,
    "GZIP": 2,
    "DEFLATE": 3,
    "BZIP2": 4,
    "SNAPPY": 5,
    "SNAPPY_BLOCKED": 6,
    "LZO": 7,
    "LZ4": 8,
  }

class TTablePropertyType(object):
  TBL_PROPERTY = 0
  SERDE_PROPERTY = 1

  _VALUES_TO_NAMES = {
    0: "TBL_PROPERTY",
    1: "SERDE_PROPERTY",
  }

  _NAMES_TO_VALUES = {
    "TBL_PROPERTY": 0,
    "SERDE_PROPERTY": 1,
  }

class TAccessLevel(object):
  NONE = 0
  READ_WRITE = 1
  READ_ONLY = 2
  WRITE_ONLY = 3

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "READ_WRITE",
    2: "READ_ONLY",
    3: "WRITE_ONLY",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "READ_WRITE": 1,
    "READ_ONLY": 2,
    "WRITE_ONLY": 3,
  }

class TPrivilegeScope(object):
  SERVER = 0
  URI = 1
  DATABASE = 2
  TABLE = 3

  _VALUES_TO_NAMES = {
    0: "SERVER",
    1: "URI",
    2: "DATABASE",
    3: "TABLE",
  }

  _NAMES_TO_VALUES = {
    "SERVER": 0,
    "URI": 1,
    "DATABASE": 2,
    "TABLE": 3,
  }


class TPartitionKeyValue(object):
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartitionKeyValue')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableName(object):
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableName')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableStats(object):
  """
  Attributes:
   - num_rows
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'num_rows', None, None, ), # 1
  )

  def __init__(self, num_rows=None,):
    self.num_rows = num_rows

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.num_rows = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableStats')
    if self.num_rows is not None:
      oprot.writeFieldBegin('num_rows', TType.I64, 1)
      oprot.writeI64(self.num_rows)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_rows is None:
      raise TProtocol.TProtocolException(message='Required field num_rows is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnStats(object):
  """
  Attributes:
   - avg_size
   - max_size
   - num_distinct_values
   - num_nulls
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'avg_size', None, None, ), # 1
    (2, TType.I64, 'max_size', None, None, ), # 2
    (3, TType.I64, 'num_distinct_values', None, None, ), # 3
    (4, TType.I64, 'num_nulls', None, None, ), # 4
  )

  def __init__(self, avg_size=None, max_size=None, num_distinct_values=None, num_nulls=None,):
    self.avg_size = avg_size
    self.max_size = max_size
    self.num_distinct_values = num_distinct_values
    self.num_nulls = num_nulls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.avg_size = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.max_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.num_distinct_values = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.num_nulls = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnStats')
    if self.avg_size is not None:
      oprot.writeFieldBegin('avg_size', TType.DOUBLE, 1)
      oprot.writeDouble(self.avg_size)
      oprot.writeFieldEnd()
    if self.max_size is not None:
      oprot.writeFieldBegin('max_size', TType.I64, 2)
      oprot.writeI64(self.max_size)
      oprot.writeFieldEnd()
    if self.num_distinct_values is not None:
      oprot.writeFieldBegin('num_distinct_values', TType.I64, 3)
      oprot.writeI64(self.num_distinct_values)
      oprot.writeFieldEnd()
    if self.num_nulls is not None:
      oprot.writeFieldBegin('num_nulls', TType.I64, 4)
      oprot.writeI64(self.num_nulls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.avg_size is None:
      raise TProtocol.TProtocolException(message='Required field avg_size is unset!')
    if self.max_size is None:
      raise TProtocol.TProtocolException(message='Required field max_size is unset!')
    if self.num_distinct_values is None:
      raise TProtocol.TProtocolException(message='Required field num_distinct_values is unset!')
    if self.num_nulls is None:
      raise TProtocol.TProtocolException(message='Required field num_nulls is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumn(object):
  """
  Attributes:
   - columnName
   - columnType
   - comment
   - col_stats
   - position
   - is_hbase_column
   - column_family
   - column_qualifier
   - is_binary
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'columnName', None, None, ), # 1
    (2, TType.STRUCT, 'columnType', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
    (4, TType.STRUCT, 'col_stats', (TColumnStats, TColumnStats.thrift_spec), None, ), # 4
    (5, TType.I32, 'position', None, None, ), # 5
    (6, TType.BOOL, 'is_hbase_column', None, None, ), # 6
    (7, TType.STRING, 'column_family', None, None, ), # 7
    (8, TType.STRING, 'column_qualifier', None, None, ), # 8
    (9, TType.BOOL, 'is_binary', None, None, ), # 9
  )

  def __init__(self, columnName=None, columnType=None, comment=None, col_stats=None, position=None, is_hbase_column=None, column_family=None, column_qualifier=None, is_binary=None,):
    self.columnName = columnName
    self.columnType = columnType
    self.comment = comment
    self.col_stats = col_stats
    self.position = position
    self.is_hbase_column = is_hbase_column
    self.column_family = column_family
    self.column_qualifier = column_qualifier
    self.is_binary = is_binary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.columnType = Types.ttypes.TColumnType()
          self.columnType.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.col_stats = TColumnStats()
          self.col_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.position = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_hbase_column = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.column_family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.column_qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.is_binary = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumn')
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 1)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    if self.columnType is not None:
      oprot.writeFieldBegin('columnType', TType.STRUCT, 2)
      self.columnType.write(oprot)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.col_stats is not None:
      oprot.writeFieldBegin('col_stats', TType.STRUCT, 4)
      self.col_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 5)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.is_hbase_column is not None:
      oprot.writeFieldBegin('is_hbase_column', TType.BOOL, 6)
      oprot.writeBool(self.is_hbase_column)
      oprot.writeFieldEnd()
    if self.column_family is not None:
      oprot.writeFieldBegin('column_family', TType.STRING, 7)
      oprot.writeString(self.column_family)
      oprot.writeFieldEnd()
    if self.column_qualifier is not None:
      oprot.writeFieldBegin('column_qualifier', TType.STRING, 8)
      oprot.writeString(self.column_qualifier)
      oprot.writeFieldEnd()
    if self.is_binary is not None:
      oprot.writeFieldBegin('is_binary', TType.BOOL, 9)
      oprot.writeBool(self.is_binary)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnName is None:
      raise TProtocol.TProtocolException(message='Required field columnName is unset!')
    if self.columnType is None:
      raise TProtocol.TProtocolException(message='Required field columnType is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsFileBlock(object):
  """
  Attributes:
   - offset
   - length
   - replica_host_idxs
   - disk_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'offset', None, None, ), # 1
    (2, TType.I64, 'length', None, None, ), # 2
    (3, TType.LIST, 'replica_host_idxs', (TType.I32,None), None, ), # 3
    (4, TType.LIST, 'disk_ids', (TType.I32,None), None, ), # 4
  )

  def __init__(self, offset=None, length=None, replica_host_idxs=None, disk_ids=None,):
    self.offset = offset
    self.length = length
    self.replica_host_idxs = replica_host_idxs
    self.disk_ids = disk_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.replica_host_idxs = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.replica_host_idxs.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.disk_ids = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readI32();
            self.disk_ids.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileBlock')
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 1)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 2)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.replica_host_idxs is not None:
      oprot.writeFieldBegin('replica_host_idxs', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.replica_host_idxs))
      for iter12 in self.replica_host_idxs:
        oprot.writeI32(iter12)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.disk_ids is not None:
      oprot.writeFieldBegin('disk_ids', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.disk_ids))
      for iter13 in self.disk_ids:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.length is None:
      raise TProtocol.TProtocolException(message='Required field length is unset!')
    if self.replica_host_idxs is None:
      raise TProtocol.TProtocolException(message='Required field replica_host_idxs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsFileDesc(object):
  """
  Attributes:
   - file_name
   - length
   - compression
   - last_modification_time
   - file_blocks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'file_name', None, None, ), # 1
    (2, TType.I64, 'length', None, None, ), # 2
    (3, TType.I32, 'compression', None, None, ), # 3
    (4, TType.I64, 'last_modification_time', None, None, ), # 4
    (5, TType.LIST, 'file_blocks', (TType.STRUCT,(THdfsFileBlock, THdfsFileBlock.thrift_spec)), None, ), # 5
  )

  def __init__(self, file_name=None, length=None, compression=None, last_modification_time=None, file_blocks=None,):
    self.file_name = file_name
    self.length = length
    self.compression = compression
    self.last_modification_time = last_modification_time
    self.file_blocks = file_blocks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.file_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.compression = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.last_modification_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.file_blocks = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = THdfsFileBlock()
            _elem19.read(iprot)
            self.file_blocks.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileDesc')
    if self.file_name is not None:
      oprot.writeFieldBegin('file_name', TType.STRING, 1)
      oprot.writeString(self.file_name)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 2)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.compression is not None:
      oprot.writeFieldBegin('compression', TType.I32, 3)
      oprot.writeI32(self.compression)
      oprot.writeFieldEnd()
    if self.last_modification_time is not None:
      oprot.writeFieldBegin('last_modification_time', TType.I64, 4)
      oprot.writeI64(self.last_modification_time)
      oprot.writeFieldEnd()
    if self.file_blocks is not None:
      oprot.writeFieldBegin('file_blocks', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.file_blocks))
      for iter20 in self.file_blocks:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_name is None:
      raise TProtocol.TProtocolException(message='Required field file_name is unset!')
    if self.length is None:
      raise TProtocol.TProtocolException(message='Required field length is unset!')
    if self.compression is None:
      raise TProtocol.TProtocolException(message='Required field compression is unset!')
    if self.last_modification_time is None:
      raise TProtocol.TProtocolException(message='Required field last_modification_time is unset!')
    if self.file_blocks is None:
      raise TProtocol.TProtocolException(message='Required field file_blocks is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsPartition(object):
  """
  Attributes:
   - lineDelim
   - fieldDelim
   - collectionDelim
   - mapKeyDelim
   - escapeChar
   - fileFormat
   - partitionKeyExprs
   - blockSize
   - compression
   - file_desc
   - location
   - access_level
   - stats
   - is_marked_cached
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'lineDelim', None, None, ), # 1
    (2, TType.BYTE, 'fieldDelim', None, None, ), # 2
    (3, TType.BYTE, 'collectionDelim', None, None, ), # 3
    (4, TType.BYTE, 'mapKeyDelim', None, None, ), # 4
    (5, TType.BYTE, 'escapeChar', None, None, ), # 5
    (6, TType.I32, 'fileFormat', None, None, ), # 6
    (7, TType.LIST, 'partitionKeyExprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.I32, 'blockSize', None, None, ), # 8
    (9, TType.I32, 'compression', None, None, ), # 9
    (10, TType.LIST, 'file_desc', (TType.STRUCT,(THdfsFileDesc, THdfsFileDesc.thrift_spec)), None, ), # 10
    (11, TType.STRING, 'location', None, None, ), # 11
    (12, TType.I32, 'access_level', None, None, ), # 12
    (13, TType.STRUCT, 'stats', (TTableStats, TTableStats.thrift_spec), None, ), # 13
    (14, TType.BOOL, 'is_marked_cached', None, None, ), # 14
    (15, TType.I64, 'id', None, None, ), # 15
  )

  def __init__(self, lineDelim=None, fieldDelim=None, collectionDelim=None, mapKeyDelim=None, escapeChar=None, fileFormat=None, partitionKeyExprs=None, blockSize=None, compression=None, file_desc=None, location=None, access_level=None, stats=None, is_marked_cached=None, id=None,):
    self.lineDelim = lineDelim
    self.fieldDelim = fieldDelim
    self.collectionDelim = collectionDelim
    self.mapKeyDelim = mapKeyDelim
    self.escapeChar = escapeChar
    self.fileFormat = fileFormat
    self.partitionKeyExprs = partitionKeyExprs
    self.blockSize = blockSize
    self.compression = compression
    self.file_desc = file_desc
    self.location = location
    self.access_level = access_level
    self.stats = stats
    self.is_marked_cached = is_marked_cached
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.lineDelim = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.fieldDelim = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.collectionDelim = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.mapKeyDelim = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.escapeChar = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.fileFormat = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.partitionKeyExprs = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Exprs.ttypes.TExpr()
            _elem26.read(iprot)
            self.partitionKeyExprs.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.blockSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.compression = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.file_desc = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = THdfsFileDesc()
            _elem32.read(iprot)
            self.file_desc.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.access_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.stats = TTableStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.is_marked_cached = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsPartition')
    if self.lineDelim is not None:
      oprot.writeFieldBegin('lineDelim', TType.BYTE, 1)
      oprot.writeByte(self.lineDelim)
      oprot.writeFieldEnd()
    if self.fieldDelim is not None:
      oprot.writeFieldBegin('fieldDelim', TType.BYTE, 2)
      oprot.writeByte(self.fieldDelim)
      oprot.writeFieldEnd()
    if self.collectionDelim is not None:
      oprot.writeFieldBegin('collectionDelim', TType.BYTE, 3)
      oprot.writeByte(self.collectionDelim)
      oprot.writeFieldEnd()
    if self.mapKeyDelim is not None:
      oprot.writeFieldBegin('mapKeyDelim', TType.BYTE, 4)
      oprot.writeByte(self.mapKeyDelim)
      oprot.writeFieldEnd()
    if self.escapeChar is not None:
      oprot.writeFieldBegin('escapeChar', TType.BYTE, 5)
      oprot.writeByte(self.escapeChar)
      oprot.writeFieldEnd()
    if self.fileFormat is not None:
      oprot.writeFieldBegin('fileFormat', TType.I32, 6)
      oprot.writeI32(self.fileFormat)
      oprot.writeFieldEnd()
    if self.partitionKeyExprs is not None:
      oprot.writeFieldBegin('partitionKeyExprs', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeyExprs))
      for iter33 in self.partitionKeyExprs:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.blockSize is not None:
      oprot.writeFieldBegin('blockSize', TType.I32, 8)
      oprot.writeI32(self.blockSize)
      oprot.writeFieldEnd()
    if self.compression is not None:
      oprot.writeFieldBegin('compression', TType.I32, 9)
      oprot.writeI32(self.compression)
      oprot.writeFieldEnd()
    if self.file_desc is not None:
      oprot.writeFieldBegin('file_desc', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.file_desc))
      for iter34 in self.file_desc:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 11)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.access_level is not None:
      oprot.writeFieldBegin('access_level', TType.I32, 12)
      oprot.writeI32(self.access_level)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 13)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.is_marked_cached is not None:
      oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 14)
      oprot.writeBool(self.is_marked_cached)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 15)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.lineDelim is None:
      raise TProtocol.TProtocolException(message='Required field lineDelim is unset!')
    if self.fieldDelim is None:
      raise TProtocol.TProtocolException(message='Required field fieldDelim is unset!')
    if self.collectionDelim is None:
      raise TProtocol.TProtocolException(message='Required field collectionDelim is unset!')
    if self.mapKeyDelim is None:
      raise TProtocol.TProtocolException(message='Required field mapKeyDelim is unset!')
    if self.escapeChar is None:
      raise TProtocol.TProtocolException(message='Required field escapeChar is unset!')
    if self.fileFormat is None:
      raise TProtocol.TProtocolException(message='Required field fileFormat is unset!')
    if self.blockSize is None:
      raise TProtocol.TProtocolException(message='Required field blockSize is unset!')
    if self.compression is None:
      raise TProtocol.TProtocolException(message='Required field compression is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsTable(object):
  """
  Attributes:
   - hdfsBaseDir
   - colNames
   - nullPartitionKeyValue
   - nullColumnValue
   - avroSchema
   - partitions
   - network_addresses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hdfsBaseDir', None, None, ), # 1
    (2, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'nullPartitionKeyValue', None, None, ), # 3
    (4, TType.MAP, 'partitions', (TType.I64,None,TType.STRUCT,(THdfsPartition, THdfsPartition.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'nullColumnValue', None, None, ), # 5
    (6, TType.STRING, 'avroSchema', None, None, ), # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT,(Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec)), None, ), # 7
  )

  def __init__(self, hdfsBaseDir=None, colNames=None, nullPartitionKeyValue=None, nullColumnValue=None, avroSchema=None, partitions=None, network_addresses=None,):
    self.hdfsBaseDir = hdfsBaseDir
    self.colNames = colNames
    self.nullPartitionKeyValue = nullPartitionKeyValue
    self.nullColumnValue = nullColumnValue
    self.avroSchema = avroSchema
    self.partitions = partitions
    self.network_addresses = network_addresses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hdfsBaseDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readString();
            self.colNames.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nullPartitionKeyValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.nullColumnValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.avroSchema = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.partitions = {}
          (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin()
          for _i45 in xrange(_size41):
            _key46 = iprot.readI64();
            _val47 = THdfsPartition()
            _val47.read(iprot)
            self.partitions[_key46] = _val47
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.network_addresses = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = Types.ttypes.TNetworkAddress()
            _elem53.read(iprot)
            self.network_addresses.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsTable')
    if self.hdfsBaseDir is not None:
      oprot.writeFieldBegin('hdfsBaseDir', TType.STRING, 1)
      oprot.writeString(self.hdfsBaseDir)
      oprot.writeFieldEnd()
    if self.colNames is not None:
      oprot.writeFieldBegin('colNames', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter54 in self.colNames:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullPartitionKeyValue is not None:
      oprot.writeFieldBegin('nullPartitionKeyValue', TType.STRING, 3)
      oprot.writeString(self.nullPartitionKeyValue)
      oprot.writeFieldEnd()
    if self.partitions is not None:
      oprot.writeFieldBegin('partitions', TType.MAP, 4)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.partitions))
      for kiter55,viter56 in self.partitions.items():
        oprot.writeI64(kiter55)
        viter56.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.nullColumnValue is not None:
      oprot.writeFieldBegin('nullColumnValue', TType.STRING, 5)
      oprot.writeString(self.nullColumnValue)
      oprot.writeFieldEnd()
    if self.avroSchema is not None:
      oprot.writeFieldBegin('avroSchema', TType.STRING, 6)
      oprot.writeString(self.avroSchema)
      oprot.writeFieldEnd()
    if self.network_addresses is not None:
      oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
      for iter57 in self.network_addresses:
        iter57.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hdfsBaseDir is None:
      raise TProtocol.TProtocolException(message='Required field hdfsBaseDir is unset!')
    if self.colNames is None:
      raise TProtocol.TProtocolException(message='Required field colNames is unset!')
    if self.nullPartitionKeyValue is None:
      raise TProtocol.TProtocolException(message='Required field nullPartitionKeyValue is unset!')
    if self.nullColumnValue is None:
      raise TProtocol.TProtocolException(message='Required field nullColumnValue is unset!')
    if self.partitions is None:
      raise TProtocol.TProtocolException(message='Required field partitions is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseTable(object):
  """
  Attributes:
   - tableName
   - families
   - qualifiers
   - binary_encoded
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.LIST, 'families', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'qualifiers', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'binary_encoded', (TType.BOOL,None), None, ), # 4
  )

  def __init__(self, tableName=None, families=None, qualifiers=None, binary_encoded=None,):
    self.tableName = tableName
    self.families = families
    self.qualifiers = qualifiers
    self.binary_encoded = binary_encoded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.families = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = iprot.readString();
            self.families.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.qualifiers = []
          (_etype67, _size64) = iprot.readListBegin()
          for _i68 in xrange(_size64):
            _elem69 = iprot.readString();
            self.qualifiers.append(_elem69)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.binary_encoded = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readBool();
            self.binary_encoded.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseTable')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.families is not None:
      oprot.writeFieldBegin('families', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.families))
      for iter76 in self.families:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.qualifiers is not None:
      oprot.writeFieldBegin('qualifiers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.qualifiers))
      for iter77 in self.qualifiers:
        oprot.writeString(iter77)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binary_encoded is not None:
      oprot.writeFieldBegin('binary_encoded', TType.LIST, 4)
      oprot.writeListBegin(TType.BOOL, len(self.binary_encoded))
      for iter78 in self.binary_encoded:
        oprot.writeBool(iter78)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    if self.families is None:
      raise TProtocol.TProtocolException(message='Required field families is unset!')
    if self.qualifiers is None:
      raise TProtocol.TProtocolException(message='Required field qualifiers is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSource(object):
  """
  Attributes:
   - name
   - hdfs_location
   - class_name
   - api_version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'hdfs_location', None, None, ), # 2
    (3, TType.STRING, 'class_name', None, None, ), # 3
    (4, TType.STRING, 'api_version', None, None, ), # 4
  )

  def __init__(self, name=None, hdfs_location=None, class_name=None, api_version=None,):
    self.name = name
    self.hdfs_location = hdfs_location
    self.class_name = class_name
    self.api_version = api_version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfs_location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.class_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.api_version = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSource')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.hdfs_location is not None:
      oprot.writeFieldBegin('hdfs_location', TType.STRING, 2)
      oprot.writeString(self.hdfs_location)
      oprot.writeFieldEnd()
    if self.class_name is not None:
      oprot.writeFieldBegin('class_name', TType.STRING, 3)
      oprot.writeString(self.class_name)
      oprot.writeFieldEnd()
    if self.api_version is not None:
      oprot.writeFieldBegin('api_version', TType.STRING, 4)
      oprot.writeString(self.api_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.hdfs_location is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_location is unset!')
    if self.class_name is None:
      raise TProtocol.TProtocolException(message='Required field class_name is unset!')
    if self.api_version is None:
      raise TProtocol.TProtocolException(message='Required field api_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSourceTable(object):
  """
  Attributes:
   - data_source
   - init_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data_source', (TDataSource, TDataSource.thrift_spec), None, ), # 1
    (2, TType.STRING, 'init_string', None, None, ), # 2
  )

  def __init__(self, data_source=None, init_string=None,):
    self.data_source = data_source
    self.init_string = init_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data_source = TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.init_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSourceTable')
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.init_string is not None:
      oprot.writeFieldBegin('init_string', TType.STRING, 2)
      oprot.writeString(self.init_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    if self.init_string is None:
      raise TProtocol.TProtocolException(message='Required field init_string is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTable(object):
  """
  Attributes:
   - db_name
   - tbl_name
   - load_status
   - id
   - access_level
   - columns
   - clustering_columns
   - table_stats
   - table_type
   - hdfs_table
   - hbase_table
   - metastore_table
   - data_source_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'load_status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 3
    (4, TType.I32, 'id', None, None, ), # 4
    (5, TType.I32, 'access_level', None, None, ), # 5
    (6, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'clustering_columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 7
    (8, TType.STRUCT, 'table_stats', (TTableStats, TTableStats.thrift_spec), None, ), # 8
    (9, TType.I32, 'table_type', None, None, ), # 9
    (10, TType.STRUCT, 'hdfs_table', (THdfsTable, THdfsTable.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'hbase_table', (THBaseTable, THBaseTable.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'metastore_table', (hive_metastore.ttypes.Table, hive_metastore.ttypes.Table.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'data_source_table', (TDataSourceTable, TDataSourceTable.thrift_spec), None, ), # 13
  )

  def __init__(self, db_name=None, tbl_name=None, load_status=None, id=None, access_level=None, columns=None, clustering_columns=None, table_stats=None, table_type=None, hdfs_table=None, hbase_table=None, metastore_table=None, data_source_table=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.load_status = load_status
    self.id = id
    self.access_level = access_level
    self.columns = columns
    self.clustering_columns = clustering_columns
    self.table_stats = table_stats
    self.table_type = table_type
    self.hdfs_table = hdfs_table
    self.hbase_table = hbase_table
    self.metastore_table = metastore_table
    self.data_source_table = data_source_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.load_status = Status.ttypes.TStatus()
          self.load_status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.access_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.columns = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = TColumn()
            _elem84.read(iprot)
            self.columns.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.clustering_columns = []
          (_etype88, _size85) = iprot.readListBegin()
          for _i89 in xrange(_size85):
            _elem90 = TColumn()
            _elem90.read(iprot)
            self.clustering_columns.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.table_stats = TTableStats()
          self.table_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.table_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.hdfs_table = THdfsTable()
          self.hdfs_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.hbase_table = THBaseTable()
          self.hbase_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.metastore_table = hive_metastore.ttypes.Table()
          self.metastore_table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.data_source_table = TDataSourceTable()
          self.data_source_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTable')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.load_status is not None:
      oprot.writeFieldBegin('load_status', TType.STRUCT, 3)
      self.load_status.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 4)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.access_level is not None:
      oprot.writeFieldBegin('access_level', TType.I32, 5)
      oprot.writeI32(self.access_level)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter91 in self.columns:
        iter91.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clustering_columns is not None:
      oprot.writeFieldBegin('clustering_columns', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.clustering_columns))
      for iter92 in self.clustering_columns:
        iter92.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.table_stats is not None:
      oprot.writeFieldBegin('table_stats', TType.STRUCT, 8)
      self.table_stats.write(oprot)
      oprot.writeFieldEnd()
    if self.table_type is not None:
      oprot.writeFieldBegin('table_type', TType.I32, 9)
      oprot.writeI32(self.table_type)
      oprot.writeFieldEnd()
    if self.hdfs_table is not None:
      oprot.writeFieldBegin('hdfs_table', TType.STRUCT, 10)
      self.hdfs_table.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_table is not None:
      oprot.writeFieldBegin('hbase_table', TType.STRUCT, 11)
      self.hbase_table.write(oprot)
      oprot.writeFieldEnd()
    if self.metastore_table is not None:
      oprot.writeFieldBegin('metastore_table', TType.STRUCT, 12)
      self.metastore_table.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source_table is not None:
      oprot.writeFieldBegin('data_source_table', TType.STRUCT, 13)
      self.data_source_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDatabase(object):
  """
  Attributes:
   - db_name
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
  )

  def __init__(self, db_name=None, location=None,):
    self.db_name = db_name
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDatabase')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRole(object):
  """
  Attributes:
   - role_name
   - role_id
   - grant_groups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.I32, 'role_id', None, None, ), # 2
    (3, TType.LIST, 'grant_groups', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, role_name=None, role_id=None, grant_groups=None,):
    self.role_name = role_name
    self.role_id = role_id
    self.grant_groups = grant_groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.role_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.grant_groups = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = iprot.readString();
            self.grant_groups.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRole')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.role_id is not None:
      oprot.writeFieldBegin('role_id', TType.I32, 2)
      oprot.writeI32(self.role_id)
      oprot.writeFieldEnd()
    if self.grant_groups is not None:
      oprot.writeFieldBegin('grant_groups', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.grant_groups))
      for iter99 in self.grant_groups:
        oprot.writeString(iter99)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.role_name is None:
      raise TProtocol.TProtocolException(message='Required field role_name is unset!')
    if self.role_id is None:
      raise TProtocol.TProtocolException(message='Required field role_id is unset!')
    if self.grant_groups is None:
      raise TProtocol.TProtocolException(message='Required field grant_groups is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPrivilege(object):
  """
  Attributes:
   - privilege_name
   - scope
   - role_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'privilege_name', None, None, ), # 1
    (2, TType.I32, 'scope', None, None, ), # 2
    (3, TType.I32, 'role_id', None, None, ), # 3
  )

  def __init__(self, privilege_name=None, scope=None, role_id=None,):
    self.privilege_name = privilege_name
    self.scope = scope
    self.role_id = role_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.privilege_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scope = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.role_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPrivilege')
    if self.privilege_name is not None:
      oprot.writeFieldBegin('privilege_name', TType.STRING, 1)
      oprot.writeString(self.privilege_name)
      oprot.writeFieldEnd()
    if self.scope is not None:
      oprot.writeFieldBegin('scope', TType.I32, 2)
      oprot.writeI32(self.scope)
      oprot.writeFieldEnd()
    if self.role_id is not None:
      oprot.writeFieldBegin('role_id', TType.I32, 3)
      oprot.writeI32(self.role_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.privilege_name is None:
      raise TProtocol.TProtocolException(message='Required field privilege_name is unset!')
    if self.scope is None:
      raise TProtocol.TProtocolException(message='Required field scope is unset!')
    if self.role_id is None:
      raise TProtocol.TProtocolException(message='Required field role_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsCachePool(object):
  """
  Attributes:
   - pool_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_name', None, None, ), # 1
  )

  def __init__(self, pool_name=None,):
    self.pool_name = pool_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsCachePool')
    if self.pool_name is not None:
      oprot.writeFieldBegin('pool_name', TType.STRING, 1)
      oprot.writeString(self.pool_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pool_name is None:
      raise TProtocol.TProtocolException(message='Required field pool_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalog(object):
  """
  Attributes:
   - catalog_service_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog_service_id=None,):
    self.catalog_service_id = catalog_service_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalog')
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogObject(object):
  """
  Attributes:
   - type
   - catalog_version
   - catalog
   - db
   - table
   - fn
   - data_source
   - role
   - privilege
   - cache_pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'catalog_version', None, None, ), # 2
    (3, TType.STRUCT, 'catalog', (TCatalog, TCatalog.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'db', (TDatabase, TDatabase.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'table', (TTable, TTable.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'data_source', (TDataSource, TDataSource.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'role', (TRole, TRole.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'privilege', (TPrivilege, TPrivilege.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'cache_pool', (THdfsCachePool, THdfsCachePool.thrift_spec), None, ), # 10
  )

  def __init__(self, type=None, catalog_version=None, catalog=None, db=None, table=None, fn=None, data_source=None, role=None, privilege=None, cache_pool=None,):
    self.type = type
    self.catalog_version = catalog_version
    self.catalog = catalog
    self.db = db
    self.table = table
    self.fn = fn
    self.data_source = data_source
    self.role = role
    self.privilege = privilege
    self.cache_pool = cache_pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.catalog_version = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.catalog = TCatalog()
          self.catalog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.db = TDatabase()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.table = TTable()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.data_source = TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.role = TRole()
          self.role.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.privilege = TPrivilege()
          self.privilege.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.cache_pool = THdfsCachePool()
          self.cache_pool.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogObject')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.catalog_version is not None:
      oprot.writeFieldBegin('catalog_version', TType.I64, 2)
      oprot.writeI64(self.catalog_version)
      oprot.writeFieldEnd()
    if self.catalog is not None:
      oprot.writeFieldBegin('catalog', TType.STRUCT, 3)
      self.catalog.write(oprot)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 4)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 5)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 6)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 7)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRUCT, 8)
      self.role.write(oprot)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRUCT, 9)
      self.privilege.write(oprot)
      oprot.writeFieldEnd()
    if self.cache_pool is not None:
      oprot.writeFieldBegin('cache_pool', TType.STRUCT, 10)
      self.cache_pool.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.catalog_version is None:
      raise TProtocol.TProtocolException(message='Required field catalog_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
