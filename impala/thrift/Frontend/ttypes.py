#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Types.ttypes
import ImpalaInternalService.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import Descriptors.ttypes
import Data.ttypes
import Exprs.ttypes
import cli_service.ttypes
import Status.ttypes
import CatalogObjects.ttypes
import CatalogService.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TDescribeTableOutputStyle(object):
  MINIMAL = 0
  FORMATTED = 1

  _VALUES_TO_NAMES = {
    0: "MINIMAL",
    1: "FORMATTED",
  }

  _NAMES_TO_VALUES = {
    "MINIMAL": 0,
    "FORMATTED": 1,
  }

class TCatalogOpType(object):
  SHOW_TABLES = 0
  SHOW_DBS = 1
  SHOW_STATS = 2
  USE = 3
  DESCRIBE = 4
  SHOW_FUNCTIONS = 5
  RESET_METADATA = 6
  DDL = 7
  SHOW_CREATE_TABLE = 8
  SHOW_DATA_SRCS = 9

  _VALUES_TO_NAMES = {
    0: "SHOW_TABLES",
    1: "SHOW_DBS",
    2: "SHOW_STATS",
    3: "USE",
    4: "DESCRIBE",
    5: "SHOW_FUNCTIONS",
    6: "RESET_METADATA",
    7: "DDL",
    8: "SHOW_CREATE_TABLE",
    9: "SHOW_DATA_SRCS",
  }

  _NAMES_TO_VALUES = {
    "SHOW_TABLES": 0,
    "SHOW_DBS": 1,
    "SHOW_STATS": 2,
    "USE": 3,
    "DESCRIBE": 4,
    "SHOW_FUNCTIONS": 5,
    "RESET_METADATA": 6,
    "DDL": 7,
    "SHOW_CREATE_TABLE": 8,
    "SHOW_DATA_SRCS": 9,
  }

class TMetadataOpcode(object):
  GET_TYPE_INFO = 0
  GET_CATALOGS = 1
  GET_SCHEMAS = 2
  GET_TABLES = 3
  GET_TABLE_TYPES = 4
  GET_COLUMNS = 5
  GET_FUNCTIONS = 6

  _VALUES_TO_NAMES = {
    0: "GET_TYPE_INFO",
    1: "GET_CATALOGS",
    2: "GET_SCHEMAS",
    3: "GET_TABLES",
    4: "GET_TABLE_TYPES",
    5: "GET_COLUMNS",
    6: "GET_FUNCTIONS",
  }

  _NAMES_TO_VALUES = {
    "GET_TYPE_INFO": 0,
    "GET_CATALOGS": 1,
    "GET_SCHEMAS": 2,
    "GET_TABLES": 3,
    "GET_TABLE_TYPES": 4,
    "GET_COLUMNS": 5,
    "GET_FUNCTIONS": 6,
  }

class TSymbolType(object):
  UDF_EVALUATE = 0
  UDF_PREPARE = 1
  UDF_CLOSE = 2

  _VALUES_TO_NAMES = {
    0: "UDF_EVALUATE",
    1: "UDF_PREPARE",
    2: "UDF_CLOSE",
  }

  _NAMES_TO_VALUES = {
    "UDF_EVALUATE": 0,
    "UDF_PREPARE": 1,
    "UDF_CLOSE": 2,
  }

class TSymbolLookupResultCode(object):
  SYMBOL_FOUND = 0
  BINARY_NOT_FOUND = 1
  SYMBOL_NOT_FOUND = 2

  _VALUES_TO_NAMES = {
    0: "SYMBOL_FOUND",
    1: "BINARY_NOT_FOUND",
    2: "SYMBOL_NOT_FOUND",
  }

  _NAMES_TO_VALUES = {
    "SYMBOL_FOUND": 0,
    "BINARY_NOT_FOUND": 1,
    "SYMBOL_NOT_FOUND": 2,
  }


class THiveUdfExecutorCtorParams(object):
  """
  Attributes:
   - fn
   - local_location
   - input_byte_offsets
   - input_nulls_ptr
   - input_buffer_ptr
   - output_null_ptr
   - output_buffer_ptr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fn', (Types.ttypes.TFunction, Types.ttypes.TFunction.thrift_spec), None, ), # 1
    (2, TType.STRING, 'local_location', None, None, ), # 2
    (3, TType.LIST, 'input_byte_offsets', (TType.I32,None), None, ), # 3
    (4, TType.I64, 'input_nulls_ptr', None, None, ), # 4
    (5, TType.I64, 'input_buffer_ptr', None, None, ), # 5
    (6, TType.I64, 'output_null_ptr', None, None, ), # 6
    (7, TType.I64, 'output_buffer_ptr', None, None, ), # 7
  )

  def __init__(self, fn=None, local_location=None, input_byte_offsets=None, input_nulls_ptr=None, input_buffer_ptr=None, output_null_ptr=None, output_buffer_ptr=None,):
    self.fn = fn
    self.local_location = local_location
    self.input_byte_offsets = input_byte_offsets
    self.input_nulls_ptr = input_nulls_ptr
    self.input_buffer_ptr = input_buffer_ptr
    self.output_null_ptr = output_null_ptr
    self.output_buffer_ptr = output_buffer_ptr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fn = Types.ttypes.TFunction()
          self.fn.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.local_location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.input_byte_offsets = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.input_byte_offsets.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.input_nulls_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.input_buffer_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.output_null_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.output_buffer_ptr = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THiveUdfExecutorCtorParams')
    if self.fn is not None:
      oprot.writeFieldBegin('fn', TType.STRUCT, 1)
      self.fn.write(oprot)
      oprot.writeFieldEnd()
    if self.local_location is not None:
      oprot.writeFieldBegin('local_location', TType.STRING, 2)
      oprot.writeString(self.local_location)
      oprot.writeFieldEnd()
    if self.input_byte_offsets is not None:
      oprot.writeFieldBegin('input_byte_offsets', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.input_byte_offsets))
      for iter6 in self.input_byte_offsets:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.input_nulls_ptr is not None:
      oprot.writeFieldBegin('input_nulls_ptr', TType.I64, 4)
      oprot.writeI64(self.input_nulls_ptr)
      oprot.writeFieldEnd()
    if self.input_buffer_ptr is not None:
      oprot.writeFieldBegin('input_buffer_ptr', TType.I64, 5)
      oprot.writeI64(self.input_buffer_ptr)
      oprot.writeFieldEnd()
    if self.output_null_ptr is not None:
      oprot.writeFieldBegin('output_null_ptr', TType.I64, 6)
      oprot.writeI64(self.output_null_ptr)
      oprot.writeFieldEnd()
    if self.output_buffer_ptr is not None:
      oprot.writeFieldBegin('output_buffer_ptr', TType.I64, 7)
      oprot.writeI64(self.output_buffer_ptr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fn is None:
      raise TProtocol.TProtocolException(message='Required field fn is unset!')
    if self.local_location is None:
      raise TProtocol.TProtocolException(message='Required field local_location is unset!')
    if self.input_byte_offsets is None:
      raise TProtocol.TProtocolException(message='Required field input_byte_offsets is unset!')
    if self.input_nulls_ptr is None:
      raise TProtocol.TProtocolException(message='Required field input_nulls_ptr is unset!')
    if self.input_buffer_ptr is None:
      raise TProtocol.TProtocolException(message='Required field input_buffer_ptr is unset!')
    if self.output_null_ptr is None:
      raise TProtocol.TProtocolException(message='Required field output_null_ptr is unset!')
    if self.output_buffer_ptr is None:
      raise TProtocol.TProtocolException(message='Required field output_buffer_ptr is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesParams(object):
  """
  Attributes:
   - db
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
    (3, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 3
  )

  def __init__(self, db=None, pattern=None, session=None,):
    self.db = db
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesResult(object):
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.tables.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tables))
      for iter13 in self.tables:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsParams(object):
  """
  Attributes:
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
    (2, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 2
  )

  def __init__(self, pattern=None, session=None,):
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsParams')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsResult(object):
  """
  Attributes:
   - dbs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'dbs', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, dbs=None,):
    self.dbs = dbs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.dbs = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.dbs.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsResult')
    if self.dbs is not None:
      oprot.writeFieldBegin('dbs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.dbs))
      for iter20 in self.dbs:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDataSrcsParams(object):
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDataSrcsParams')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDataSrcsResult(object):
  """
  Attributes:
   - data_src_names
   - locations
   - class_names
   - api_versions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'data_src_names', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'locations', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'class_names', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'api_versions', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, data_src_names=None, locations=None, class_names=None, api_versions=None,):
    self.data_src_names = data_src_names
    self.locations = locations
    self.class_names = class_names
    self.api_versions = api_versions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.data_src_names = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString();
            self.data_src_names.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.locations = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString();
            self.locations.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.class_names = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = iprot.readString();
            self.class_names.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.api_versions = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = iprot.readString();
            self.api_versions.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDataSrcsResult')
    if self.data_src_names is not None:
      oprot.writeFieldBegin('data_src_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.data_src_names))
      for iter45 in self.data_src_names:
        oprot.writeString(iter45)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.locations is not None:
      oprot.writeFieldBegin('locations', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.locations))
      for iter46 in self.locations:
        oprot.writeString(iter46)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.class_names is not None:
      oprot.writeFieldBegin('class_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.class_names))
      for iter47 in self.class_names:
        oprot.writeString(iter47)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.api_versions is not None:
      oprot.writeFieldBegin('api_versions', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.api_versions))
      for iter48 in self.api_versions:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.data_src_names is None:
      raise TProtocol.TProtocolException(message='Required field data_src_names is unset!')
    if self.locations is None:
      raise TProtocol.TProtocolException(message='Required field locations is unset!')
    if self.class_names is None:
      raise TProtocol.TProtocolException(message='Required field class_names is unset!')
    if self.api_versions is None:
      raise TProtocol.TProtocolException(message='Required field api_versions is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeTableParams(object):
  """
  Attributes:
   - db
   - table_name
   - output_style
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.I32, 'output_style', None, None, ), # 3
  )

  def __init__(self, db=None, table_name=None, output_style=None,):
    self.db = db
    self.table_name = table_name
    self.output_style = output_style

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.output_style = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeTableParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.output_style is not None:
      oprot.writeFieldBegin('output_style', TType.I32, 3)
      oprot.writeI32(self.output_style)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.output_style is None:
      raise TProtocol.TProtocolException(message='Required field output_style is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeTableResult(object):
  """
  Attributes:
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRUCT,(Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, results=None,):
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Data.ttypes.TResultRow()
            _elem54.read(iprot)
            self.results.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeTableResult')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter55 in self.results:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowDataSrcsParams(object):
  """
  Attributes:
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'show_pattern', None, None, ), # 1
  )

  def __init__(self, show_pattern=None,):
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowDataSrcsParams')
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowDbsParams(object):
  """
  Attributes:
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'show_pattern', None, None, ), # 1
  )

  def __init__(self, show_pattern=None,):
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowDbsParams')
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowStatsParams(object):
  """
  Attributes:
   - is_show_col_stats
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_show_col_stats', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 2
  )

  def __init__(self, is_show_col_stats=None, table_name=None,):
    self.is_show_col_stats = is_show_col_stats
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_show_col_stats = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowStatsParams')
    if self.is_show_col_stats is not None:
      oprot.writeFieldBegin('is_show_col_stats', TType.BOOL, 1)
      oprot.writeBool(self.is_show_col_stats)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_show_col_stats is None:
      raise TProtocol.TProtocolException(message='Required field is_show_col_stats is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowFunctionsParams(object):
  """
  Attributes:
   - type
   - db
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'db', None, None, ), # 2
    (3, TType.STRING, 'show_pattern', None, None, ), # 3
  )

  def __init__(self, type=None, db=None, show_pattern=None,):
    self.type = type
    self.db = db
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowFunctionsParams')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 2)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 3)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowTablesParams(object):
  """
  Attributes:
   - db
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'show_pattern', None, None, ), # 2
  )

  def __init__(self, db=None, show_pattern=None,):
    self.db = db
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 2)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsParams(object):
  """
  Attributes:
   - type
   - db
   - pattern
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'db', None, None, ), # 2
    (3, TType.STRING, 'pattern', None, None, ), # 3
    (4, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 4
  )

  def __init__(self, type=None, db=None, pattern=None, session=None,):
    self.type = type
    self.db = db
    self.pattern = pattern
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsParams')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 2)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 3)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 4)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetFunctionsResult(object):
  """
  Attributes:
   - fn_signatures
   - fn_ret_types
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fn_signatures', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'fn_ret_types', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, fn_signatures=None, fn_ret_types=None,):
    self.fn_signatures = fn_signatures
    self.fn_ret_types = fn_ret_types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fn_signatures = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = iprot.readString();
            self.fn_signatures.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fn_ret_types = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.fn_ret_types.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetFunctionsResult')
    if self.fn_signatures is not None:
      oprot.writeFieldBegin('fn_signatures', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.fn_signatures))
      for iter68 in self.fn_signatures:
        oprot.writeString(iter68)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fn_ret_types is not None:
      oprot.writeFieldBegin('fn_ret_types', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.fn_ret_types))
      for iter69 in self.fn_ret_types:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUseDbParams(object):
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUseDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExplainResult(object):
  """
  Attributes:
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRUCT,(Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec)), None, ), # 1
  )

  def __init__(self, results=None,):
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = Data.ttypes.TResultRow()
            _elem75.read(iprot)
            self.results.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExplainResult')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter76 in self.results:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFinalizeParams(object):
  """
  Attributes:
   - is_overwrite
   - hdfs_base_dir
   - table_name
   - table_db
   - staging_dir
   - table_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_overwrite', None, None, ), # 1
    (2, TType.STRING, 'hdfs_base_dir', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'table_db', None, None, ), # 4
    (5, TType.STRING, 'staging_dir', None, None, ), # 5
    (6, TType.I64, 'table_id', None, None, ), # 6
  )

  def __init__(self, is_overwrite=None, hdfs_base_dir=None, table_name=None, table_db=None, staging_dir=None, table_id=None,):
    self.is_overwrite = is_overwrite
    self.hdfs_base_dir = hdfs_base_dir
    self.table_name = table_name
    self.table_db = table_db
    self.staging_dir = staging_dir
    self.table_id = table_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfs_base_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.staging_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.table_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFinalizeParams')
    if self.is_overwrite is not None:
      oprot.writeFieldBegin('is_overwrite', TType.BOOL, 1)
      oprot.writeBool(self.is_overwrite)
      oprot.writeFieldEnd()
    if self.hdfs_base_dir is not None:
      oprot.writeFieldBegin('hdfs_base_dir', TType.STRING, 2)
      oprot.writeString(self.hdfs_base_dir)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 4)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    if self.staging_dir is not None:
      oprot.writeFieldBegin('staging_dir', TType.STRING, 5)
      oprot.writeString(self.staging_dir)
      oprot.writeFieldEnd()
    if self.table_id is not None:
      oprot.writeFieldBegin('table_id', TType.I64, 6)
      oprot.writeI64(self.table_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_overwrite is None:
      raise TProtocol.TProtocolException(message='Required field is_overwrite is unset!')
    if self.hdfs_base_dir is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_base_dir is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.table_db is None:
      raise TProtocol.TProtocolException(message='Required field table_db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLoadDataReq(object):
  """
  Attributes:
   - table_name
   - source_path
   - overwrite
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 1
    (2, TType.STRING, 'source_path', None, None, ), # 2
    (3, TType.BOOL, 'overwrite', None, None, ), # 3
    (4, TType.LIST, 'partition_spec', (TType.STRUCT,(CatalogObjects.ttypes.TPartitionKeyValue, CatalogObjects.ttypes.TPartitionKeyValue.thrift_spec)), None, ), # 4
  )

  def __init__(self, table_name=None, source_path=None, overwrite=None, partition_spec=None,):
    self.table_name = table_name
    self.source_path = source_path
    self.overwrite = overwrite
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = CatalogObjects.ttypes.TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.source_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = CatalogObjects.ttypes.TPartitionKeyValue()
            _elem82.read(iprot)
            self.partition_spec.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLoadDataReq')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.source_path is not None:
      oprot.writeFieldBegin('source_path', TType.STRING, 2)
      oprot.writeString(self.source_path)
      oprot.writeFieldEnd()
    if self.overwrite is not None:
      oprot.writeFieldBegin('overwrite', TType.BOOL, 3)
      oprot.writeBool(self.overwrite)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter83 in self.partition_spec:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.source_path is None:
      raise TProtocol.TProtocolException(message='Required field source_path is unset!')
    if self.overwrite is None:
      raise TProtocol.TProtocolException(message='Required field overwrite is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLoadDataResp(object):
  """
  Attributes:
   - load_summary
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'load_summary', (Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec), None, ), # 1
  )

  def __init__(self, load_summary=None,):
    self.load_summary = load_summary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.load_summary = Data.ttypes.TResultRow()
          self.load_summary.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLoadDataResp')
    if self.load_summary is not None:
      oprot.writeFieldBegin('load_summary', TType.STRUCT, 1)
      self.load_summary.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.load_summary is None:
      raise TProtocol.TProtocolException(message='Required field load_summary is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryExecRequest(object):
  """
  Attributes:
   - desc_tbl
   - fragments
   - dest_fragment_idx
   - per_node_scan_ranges
   - result_set_metadata
   - finalize_params
   - query_ctx
   - query_plan
   - stmt_type
   - per_host_mem_req
   - per_host_vcores
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'desc_tbl', (Descriptors.ttypes.TDescriptorTable, Descriptors.ttypes.TDescriptorTable.thrift_spec), None, ), # 1
    (2, TType.LIST, 'fragments', (TType.STRUCT,(Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'dest_fragment_idx', (TType.I32,None), None, ), # 3
    (4, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(Planner.ttypes.TScanRangeLocations, Planner.ttypes.TScanRangeLocations.thrift_spec))), None, ), # 4
    (5, TType.STRUCT, 'result_set_metadata', (Data.ttypes.TResultSetMetadata, Data.ttypes.TResultSetMetadata.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'finalize_params', (TFinalizeParams, TFinalizeParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'query_ctx', (ImpalaInternalService.ttypes.TQueryCtx, ImpalaInternalService.ttypes.TQueryCtx.thrift_spec), None, ), # 7
    (8, TType.STRING, 'query_plan', None, None, ), # 8
    (9, TType.I32, 'stmt_type', None, None, ), # 9
    (10, TType.I64, 'per_host_mem_req', None, None, ), # 10
    (11, TType.I16, 'per_host_vcores', None, None, ), # 11
  )

  def __init__(self, desc_tbl=None, fragments=None, dest_fragment_idx=None, per_node_scan_ranges=None, result_set_metadata=None, finalize_params=None, query_ctx=None, query_plan=None, stmt_type=None, per_host_mem_req=None, per_host_vcores=None,):
    self.desc_tbl = desc_tbl
    self.fragments = fragments
    self.dest_fragment_idx = dest_fragment_idx
    self.per_node_scan_ranges = per_node_scan_ranges
    self.result_set_metadata = result_set_metadata
    self.finalize_params = finalize_params
    self.query_ctx = query_ctx
    self.query_plan = query_plan
    self.stmt_type = stmt_type
    self.per_host_mem_req = per_host_mem_req
    self.per_host_vcores = per_host_vcores

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.desc_tbl = Descriptors.ttypes.TDescriptorTable()
          self.desc_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fragments = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = Planner.ttypes.TPlanFragment()
            _elem89.read(iprot)
            self.fragments.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.dest_fragment_idx = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readI32();
            self.dest_fragment_idx.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype97, _vtype98, _size96 ) = iprot.readMapBegin()
          for _i100 in xrange(_size96):
            _key101 = iprot.readI32();
            _val102 = []
            (_etype106, _size103) = iprot.readListBegin()
            for _i107 in xrange(_size103):
              _elem108 = Planner.ttypes.TScanRangeLocations()
              _elem108.read(iprot)
              _val102.append(_elem108)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key101] = _val102
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.result_set_metadata = Data.ttypes.TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.finalize_params = TFinalizeParams()
          self.finalize_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.query_ctx = ImpalaInternalService.ttypes.TQueryCtx()
          self.query_ctx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.query_plan = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.stmt_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.per_host_mem_req = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.per_host_vcores = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryExecRequest')
    if self.desc_tbl is not None:
      oprot.writeFieldBegin('desc_tbl', TType.STRUCT, 1)
      self.desc_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.fragments is not None:
      oprot.writeFieldBegin('fragments', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.fragments))
      for iter109 in self.fragments:
        iter109.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dest_fragment_idx is not None:
      oprot.writeFieldBegin('dest_fragment_idx', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.dest_fragment_idx))
      for iter110 in self.dest_fragment_idx:
        oprot.writeI32(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter111,viter112 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter111)
        oprot.writeListBegin(TType.STRUCT, len(viter112))
        for iter113 in viter112:
          iter113.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.finalize_params is not None:
      oprot.writeFieldBegin('finalize_params', TType.STRUCT, 6)
      self.finalize_params.write(oprot)
      oprot.writeFieldEnd()
    if self.query_ctx is not None:
      oprot.writeFieldBegin('query_ctx', TType.STRUCT, 7)
      self.query_ctx.write(oprot)
      oprot.writeFieldEnd()
    if self.query_plan is not None:
      oprot.writeFieldBegin('query_plan', TType.STRING, 8)
      oprot.writeString(self.query_plan)
      oprot.writeFieldEnd()
    if self.stmt_type is not None:
      oprot.writeFieldBegin('stmt_type', TType.I32, 9)
      oprot.writeI32(self.stmt_type)
      oprot.writeFieldEnd()
    if self.per_host_mem_req is not None:
      oprot.writeFieldBegin('per_host_mem_req', TType.I64, 10)
      oprot.writeI64(self.per_host_mem_req)
      oprot.writeFieldEnd()
    if self.per_host_vcores is not None:
      oprot.writeFieldBegin('per_host_vcores', TType.I16, 11)
      oprot.writeI16(self.per_host_vcores)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragments is None:
      raise TProtocol.TProtocolException(message='Required field fragments is unset!')
    if self.query_ctx is None:
      raise TProtocol.TProtocolException(message='Required field query_ctx is unset!')
    if self.stmt_type is None:
      raise TProtocol.TProtocolException(message='Required field stmt_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogOpRequest(object):
  """
  Attributes:
   - op_type
   - use_db_params
   - describe_table_params
   - show_dbs_params
   - show_tables_params
   - show_fns_params
   - show_data_srcs_params
   - ddl_params
   - reset_metadata_params
   - show_stats_params
   - show_create_table_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'op_type', None, None, ), # 1
    (2, TType.STRUCT, 'use_db_params', (TUseDbParams, TUseDbParams.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'describe_table_params', (TDescribeTableParams, TDescribeTableParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'show_dbs_params', (TShowDbsParams, TShowDbsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'show_tables_params', (TShowTablesParams, TShowTablesParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'show_fns_params', (TShowFunctionsParams, TShowFunctionsParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'ddl_params', (CatalogService.ttypes.TDdlExecRequest, CatalogService.ttypes.TDdlExecRequest.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'reset_metadata_params', (CatalogService.ttypes.TResetMetadataRequest, CatalogService.ttypes.TResetMetadataRequest.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'show_stats_params', (TShowStatsParams, TShowStatsParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'show_create_table_params', (CatalogObjects.ttypes.TTableName, CatalogObjects.ttypes.TTableName.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'show_data_srcs_params', (TShowDataSrcsParams, TShowDataSrcsParams.thrift_spec), None, ), # 11
  )

  def __init__(self, op_type=None, use_db_params=None, describe_table_params=None, show_dbs_params=None, show_tables_params=None, show_fns_params=None, show_data_srcs_params=None, ddl_params=None, reset_metadata_params=None, show_stats_params=None, show_create_table_params=None,):
    self.op_type = op_type
    self.use_db_params = use_db_params
    self.describe_table_params = describe_table_params
    self.show_dbs_params = show_dbs_params
    self.show_tables_params = show_tables_params
    self.show_fns_params = show_fns_params
    self.show_data_srcs_params = show_data_srcs_params
    self.ddl_params = ddl_params
    self.reset_metadata_params = reset_metadata_params
    self.show_stats_params = show_stats_params
    self.show_create_table_params = show_create_table_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.use_db_params = TUseDbParams()
          self.use_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.describe_table_params = TDescribeTableParams()
          self.describe_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.show_dbs_params = TShowDbsParams()
          self.show_dbs_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.show_tables_params = TShowTablesParams()
          self.show_tables_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.show_fns_params = TShowFunctionsParams()
          self.show_fns_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.show_data_srcs_params = TShowDataSrcsParams()
          self.show_data_srcs_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.ddl_params = CatalogService.ttypes.TDdlExecRequest()
          self.ddl_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.reset_metadata_params = CatalogService.ttypes.TResetMetadataRequest()
          self.reset_metadata_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.show_stats_params = TShowStatsParams()
          self.show_stats_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.show_create_table_params = CatalogObjects.ttypes.TTableName()
          self.show_create_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogOpRequest')
    if self.op_type is not None:
      oprot.writeFieldBegin('op_type', TType.I32, 1)
      oprot.writeI32(self.op_type)
      oprot.writeFieldEnd()
    if self.use_db_params is not None:
      oprot.writeFieldBegin('use_db_params', TType.STRUCT, 2)
      self.use_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.describe_table_params is not None:
      oprot.writeFieldBegin('describe_table_params', TType.STRUCT, 3)
      self.describe_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_dbs_params is not None:
      oprot.writeFieldBegin('show_dbs_params', TType.STRUCT, 4)
      self.show_dbs_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_tables_params is not None:
      oprot.writeFieldBegin('show_tables_params', TType.STRUCT, 5)
      self.show_tables_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_fns_params is not None:
      oprot.writeFieldBegin('show_fns_params', TType.STRUCT, 6)
      self.show_fns_params.write(oprot)
      oprot.writeFieldEnd()
    if self.ddl_params is not None:
      oprot.writeFieldBegin('ddl_params', TType.STRUCT, 7)
      self.ddl_params.write(oprot)
      oprot.writeFieldEnd()
    if self.reset_metadata_params is not None:
      oprot.writeFieldBegin('reset_metadata_params', TType.STRUCT, 8)
      self.reset_metadata_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_stats_params is not None:
      oprot.writeFieldBegin('show_stats_params', TType.STRUCT, 9)
      self.show_stats_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_create_table_params is not None:
      oprot.writeFieldBegin('show_create_table_params', TType.STRUCT, 10)
      self.show_create_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_data_srcs_params is not None:
      oprot.writeFieldBegin('show_data_srcs_params', TType.STRUCT, 11)
      self.show_data_srcs_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_type is None:
      raise TProtocol.TProtocolException(message='Required field op_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMetadataOpRequest(object):
  """
  Attributes:
   - opcode
   - get_info_req
   - get_type_info_req
   - get_catalogs_req
   - get_schemas_req
   - get_tables_req
   - get_table_types_req
   - get_columns_req
   - get_functions_req
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'opcode', None, None, ), # 1
    (2, TType.STRUCT, 'get_info_req', (cli_service.ttypes.TGetInfoReq, cli_service.ttypes.TGetInfoReq.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'get_type_info_req', (cli_service.ttypes.TGetTypeInfoReq, cli_service.ttypes.TGetTypeInfoReq.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'get_catalogs_req', (cli_service.ttypes.TGetCatalogsReq, cli_service.ttypes.TGetCatalogsReq.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'get_schemas_req', (cli_service.ttypes.TGetSchemasReq, cli_service.ttypes.TGetSchemasReq.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'get_tables_req', (cli_service.ttypes.TGetTablesReq, cli_service.ttypes.TGetTablesReq.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'get_table_types_req', (cli_service.ttypes.TGetTableTypesReq, cli_service.ttypes.TGetTableTypesReq.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'get_columns_req', (cli_service.ttypes.TGetColumnsReq, cli_service.ttypes.TGetColumnsReq.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'get_functions_req', (cli_service.ttypes.TGetFunctionsReq, cli_service.ttypes.TGetFunctionsReq.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'session', (ImpalaInternalService.ttypes.TSessionState, ImpalaInternalService.ttypes.TSessionState.thrift_spec), None, ), # 10
  )

  def __init__(self, opcode=None, get_info_req=None, get_type_info_req=None, get_catalogs_req=None, get_schemas_req=None, get_tables_req=None, get_table_types_req=None, get_columns_req=None, get_functions_req=None, session=None,):
    self.opcode = opcode
    self.get_info_req = get_info_req
    self.get_type_info_req = get_type_info_req
    self.get_catalogs_req = get_catalogs_req
    self.get_schemas_req = get_schemas_req
    self.get_tables_req = get_tables_req
    self.get_table_types_req = get_table_types_req
    self.get_columns_req = get_columns_req
    self.get_functions_req = get_functions_req
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.opcode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.get_info_req = cli_service.ttypes.TGetInfoReq()
          self.get_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.get_type_info_req = cli_service.ttypes.TGetTypeInfoReq()
          self.get_type_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.get_catalogs_req = cli_service.ttypes.TGetCatalogsReq()
          self.get_catalogs_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.get_schemas_req = cli_service.ttypes.TGetSchemasReq()
          self.get_schemas_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.get_tables_req = cli_service.ttypes.TGetTablesReq()
          self.get_tables_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.get_table_types_req = cli_service.ttypes.TGetTableTypesReq()
          self.get_table_types_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.get_columns_req = cli_service.ttypes.TGetColumnsReq()
          self.get_columns_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.get_functions_req = cli_service.ttypes.TGetFunctionsReq()
          self.get_functions_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.session = ImpalaInternalService.ttypes.TSessionState()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMetadataOpRequest')
    if self.opcode is not None:
      oprot.writeFieldBegin('opcode', TType.I32, 1)
      oprot.writeI32(self.opcode)
      oprot.writeFieldEnd()
    if self.get_info_req is not None:
      oprot.writeFieldBegin('get_info_req', TType.STRUCT, 2)
      self.get_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_type_info_req is not None:
      oprot.writeFieldBegin('get_type_info_req', TType.STRUCT, 3)
      self.get_type_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_catalogs_req is not None:
      oprot.writeFieldBegin('get_catalogs_req', TType.STRUCT, 4)
      self.get_catalogs_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_schemas_req is not None:
      oprot.writeFieldBegin('get_schemas_req', TType.STRUCT, 5)
      self.get_schemas_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_tables_req is not None:
      oprot.writeFieldBegin('get_tables_req', TType.STRUCT, 6)
      self.get_tables_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_table_types_req is not None:
      oprot.writeFieldBegin('get_table_types_req', TType.STRUCT, 7)
      self.get_table_types_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_columns_req is not None:
      oprot.writeFieldBegin('get_columns_req', TType.STRUCT, 8)
      self.get_columns_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_functions_req is not None:
      oprot.writeFieldBegin('get_functions_req', TType.STRUCT, 9)
      self.get_functions_req.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 10)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.opcode is None:
      raise TProtocol.TProtocolException(message='Required field opcode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAccessEvent(object):
  """
  Attributes:
   - name
   - object_type
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'object_type', None, None, ), # 2
    (3, TType.STRING, 'privilege', None, None, ), # 3
  )

  def __init__(self, name=None, object_type=None, privilege=None,):
    self.name = name
    self.object_type = object_type
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.object_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.privilege = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAccessEvent')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.object_type is not None:
      oprot.writeFieldBegin('object_type', TType.I32, 2)
      oprot.writeI32(self.object_type)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.STRING, 3)
      oprot.writeString(self.privilege)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.object_type is None:
      raise TProtocol.TProtocolException(message='Required field object_type is unset!')
    if self.privilege is None:
      raise TProtocol.TProtocolException(message='Required field privilege is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecRequest(object):
  """
  Attributes:
   - stmt_type
   - query_options
   - query_exec_request
   - catalog_op_request
   - result_set_metadata
   - explain_result
   - load_data_request
   - access_events
   - analysis_warnings
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stmt_type', None, None, ), # 1
    (2, TType.STRUCT, 'query_options', (ImpalaInternalService.ttypes.TQueryOptions, ImpalaInternalService.ttypes.TQueryOptions.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'query_exec_request', (TQueryExecRequest, TQueryExecRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'catalog_op_request', (TCatalogOpRequest, TCatalogOpRequest.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'result_set_metadata', (Data.ttypes.TResultSetMetadata, Data.ttypes.TResultSetMetadata.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'explain_result', (TExplainResult, TExplainResult.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'load_data_request', (TLoadDataReq, TLoadDataReq.thrift_spec), None, ), # 7
    (8, TType.LIST, 'access_events', (TType.STRUCT,(TAccessEvent, TAccessEvent.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'analysis_warnings', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, stmt_type=None, query_options=None, query_exec_request=None, catalog_op_request=None, result_set_metadata=None, explain_result=None, load_data_request=None, access_events=None, analysis_warnings=None,):
    self.stmt_type = stmt_type
    self.query_options = query_options
    self.query_exec_request = query_exec_request
    self.catalog_op_request = catalog_op_request
    self.result_set_metadata = result_set_metadata
    self.explain_result = explain_result
    self.load_data_request = load_data_request
    self.access_events = access_events
    self.analysis_warnings = analysis_warnings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stmt_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_options = ImpalaInternalService.ttypes.TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.query_exec_request = TQueryExecRequest()
          self.query_exec_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.catalog_op_request = TCatalogOpRequest()
          self.catalog_op_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.result_set_metadata = Data.ttypes.TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.explain_result = TExplainResult()
          self.explain_result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.load_data_request = TLoadDataReq()
          self.load_data_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.access_events = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = TAccessEvent()
            _elem119.read(iprot)
            self.access_events.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.analysis_warnings = []
          (_etype123, _size120) = iprot.readListBegin()
          for _i124 in xrange(_size120):
            _elem125 = iprot.readString();
            self.analysis_warnings.append(_elem125)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecRequest')
    if self.stmt_type is not None:
      oprot.writeFieldBegin('stmt_type', TType.I32, 1)
      oprot.writeI32(self.stmt_type)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    if self.query_exec_request is not None:
      oprot.writeFieldBegin('query_exec_request', TType.STRUCT, 3)
      self.query_exec_request.write(oprot)
      oprot.writeFieldEnd()
    if self.catalog_op_request is not None:
      oprot.writeFieldBegin('catalog_op_request', TType.STRUCT, 4)
      self.catalog_op_request.write(oprot)
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.explain_result is not None:
      oprot.writeFieldBegin('explain_result', TType.STRUCT, 6)
      self.explain_result.write(oprot)
      oprot.writeFieldEnd()
    if self.load_data_request is not None:
      oprot.writeFieldBegin('load_data_request', TType.STRUCT, 7)
      self.load_data_request.write(oprot)
      oprot.writeFieldEnd()
    if self.access_events is not None:
      oprot.writeFieldBegin('access_events', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.access_events))
      for iter126 in self.access_events:
        iter126.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.analysis_warnings is not None:
      oprot.writeFieldBegin('analysis_warnings', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.analysis_warnings))
      for iter127 in self.analysis_warnings:
        oprot.writeString(iter127)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt_type is None:
      raise TProtocol.TProtocolException(message='Required field stmt_type is unset!')
    if self.query_options is None:
      raise TProtocol.TProtocolException(message='Required field query_options is unset!')
    if self.analysis_warnings is None:
      raise TProtocol.TProtocolException(message='Required field analysis_warnings is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCacheJarParams(object):
  """
  Attributes:
   - hdfs_location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hdfs_location', None, None, ), # 1
  )

  def __init__(self, hdfs_location=None,):
    self.hdfs_location = hdfs_location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hdfs_location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCacheJarParams')
    if self.hdfs_location is not None:
      oprot.writeFieldBegin('hdfs_location', TType.STRING, 1)
      oprot.writeString(self.hdfs_location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hdfs_location is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_location is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCacheJarResult(object):
  """
  Attributes:
   - status
   - local_path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
    (2, TType.STRING, 'local_path', None, None, ), # 2
  )

  def __init__(self, status=None, local_path=None,):
    self.status = status
    self.local_path = local_path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.local_path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCacheJarResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.local_path is not None:
      oprot.writeFieldBegin('local_path', TType.STRING, 2)
      oprot.writeString(self.local_path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSymbolLookupParams(object):
  """
  Attributes:
   - location
   - symbol
   - fn_binary_type
   - arg_types
   - has_var_args
   - ret_arg_type
   - symbol_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'location', None, None, ), # 1
    (2, TType.STRING, 'symbol', None, None, ), # 2
    (3, TType.I32, 'fn_binary_type', None, None, ), # 3
    (4, TType.LIST, 'arg_types', (TType.STRUCT,(Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec)), None, ), # 4
    (5, TType.BOOL, 'has_var_args', None, None, ), # 5
    (6, TType.STRUCT, 'ret_arg_type', (Types.ttypes.TColumnType, Types.ttypes.TColumnType.thrift_spec), None, ), # 6
    (7, TType.I32, 'symbol_type', None, None, ), # 7
  )

  def __init__(self, location=None, symbol=None, fn_binary_type=None, arg_types=None, has_var_args=None, ret_arg_type=None, symbol_type=None,):
    self.location = location
    self.symbol = symbol
    self.fn_binary_type = fn_binary_type
    self.arg_types = arg_types
    self.has_var_args = has_var_args
    self.ret_arg_type = ret_arg_type
    self.symbol_type = symbol_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.symbol = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.fn_binary_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.arg_types = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = Types.ttypes.TColumnType()
            _elem133.read(iprot)
            self.arg_types.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.has_var_args = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.ret_arg_type = Types.ttypes.TColumnType()
          self.ret_arg_type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.symbol_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSymbolLookupParams')
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 1)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.symbol is not None:
      oprot.writeFieldBegin('symbol', TType.STRING, 2)
      oprot.writeString(self.symbol)
      oprot.writeFieldEnd()
    if self.fn_binary_type is not None:
      oprot.writeFieldBegin('fn_binary_type', TType.I32, 3)
      oprot.writeI32(self.fn_binary_type)
      oprot.writeFieldEnd()
    if self.arg_types is not None:
      oprot.writeFieldBegin('arg_types', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
      for iter134 in self.arg_types:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.has_var_args is not None:
      oprot.writeFieldBegin('has_var_args', TType.BOOL, 5)
      oprot.writeBool(self.has_var_args)
      oprot.writeFieldEnd()
    if self.ret_arg_type is not None:
      oprot.writeFieldBegin('ret_arg_type', TType.STRUCT, 6)
      self.ret_arg_type.write(oprot)
      oprot.writeFieldEnd()
    if self.symbol_type is not None:
      oprot.writeFieldBegin('symbol_type', TType.I32, 7)
      oprot.writeI32(self.symbol_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    if self.symbol is None:
      raise TProtocol.TProtocolException(message='Required field symbol is unset!')
    if self.fn_binary_type is None:
      raise TProtocol.TProtocolException(message='Required field fn_binary_type is unset!')
    if self.arg_types is None:
      raise TProtocol.TProtocolException(message='Required field arg_types is unset!')
    if self.has_var_args is None:
      raise TProtocol.TProtocolException(message='Required field has_var_args is unset!')
    if self.symbol_type is None:
      raise TProtocol.TProtocolException(message='Required field symbol_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSymbolLookupResult(object):
  """
  Attributes:
   - result_code
   - symbol
   - error_msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'result_code', None, None, ), # 1
    (2, TType.STRING, 'symbol', None, None, ), # 2
    (3, TType.STRING, 'error_msg', None, None, ), # 3
  )

  def __init__(self, result_code=None, symbol=None, error_msg=None,):
    self.result_code = result_code
    self.symbol = symbol
    self.error_msg = error_msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.result_code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.symbol = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSymbolLookupResult')
    if self.result_code is not None:
      oprot.writeFieldBegin('result_code', TType.I32, 1)
      oprot.writeI32(self.result_code)
      oprot.writeFieldEnd()
    if self.symbol is not None:
      oprot.writeFieldBegin('symbol', TType.STRING, 2)
      oprot.writeString(self.symbol)
      oprot.writeFieldEnd()
    if self.error_msg is not None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 3)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result_code is None:
      raise TProtocol.TProtocolException(message='Required field result_code is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogCacheRequest(object):
  """
  Attributes:
   - is_delta
   - catalog_service_id
   - updated_objects
   - removed_objects
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_delta', None, None, ), # 1
    (2, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.LIST, 'updated_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'removed_objects', (TType.STRUCT,(CatalogObjects.ttypes.TCatalogObject, CatalogObjects.ttypes.TCatalogObject.thrift_spec)), None, ), # 4
  )

  def __init__(self, is_delta=None, catalog_service_id=None, updated_objects=None, removed_objects=None,):
    self.is_delta = is_delta
    self.catalog_service_id = catalog_service_id
    self.updated_objects = updated_objects
    self.removed_objects = removed_objects

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_delta = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.updated_objects = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = CatalogObjects.ttypes.TCatalogObject()
            _elem140.read(iprot)
            self.updated_objects.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.removed_objects = []
          (_etype144, _size141) = iprot.readListBegin()
          for _i145 in xrange(_size141):
            _elem146 = CatalogObjects.ttypes.TCatalogObject()
            _elem146.read(iprot)
            self.removed_objects.append(_elem146)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogCacheRequest')
    if self.is_delta is not None:
      oprot.writeFieldBegin('is_delta', TType.BOOL, 1)
      oprot.writeBool(self.is_delta)
      oprot.writeFieldEnd()
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 2)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_objects is not None:
      oprot.writeFieldBegin('updated_objects', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_objects))
      for iter147 in self.updated_objects:
        iter147.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.removed_objects is not None:
      oprot.writeFieldBegin('removed_objects', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.removed_objects))
      for iter148 in self.removed_objects:
        iter148.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_delta is None:
      raise TProtocol.TProtocolException(message='Required field is_delta is unset!')
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    if self.updated_objects is None:
      raise TProtocol.TProtocolException(message='Required field updated_objects is unset!')
    if self.removed_objects is None:
      raise TProtocol.TProtocolException(message='Required field removed_objects is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUpdateCatalogCacheResponse(object):
  """
  Attributes:
   - catalog_service_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'catalog_service_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
  )

  def __init__(self, catalog_service_id=None,):
    self.catalog_service_id = catalog_service_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.catalog_service_id = Types.ttypes.TUniqueId()
          self.catalog_service_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUpdateCatalogCacheResponse')
    if self.catalog_service_id is not None:
      oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
      self.catalog_service_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.catalog_service_id is None:
      raise TProtocol.TProtocolException(message='Required field catalog_service_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TJvmMemoryPool(object):
  """
  Attributes:
   - committed
   - init
   - max
   - used
   - peak_committed
   - peak_init
   - peak_max
   - peak_used
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'committed', None, None, ), # 1
    (2, TType.I64, 'init', None, None, ), # 2
    (3, TType.I64, 'max', None, None, ), # 3
    (4, TType.I64, 'used', None, None, ), # 4
    (5, TType.I64, 'peak_committed', None, None, ), # 5
    (6, TType.I64, 'peak_init', None, None, ), # 6
    (7, TType.I64, 'peak_max', None, None, ), # 7
    (8, TType.I64, 'peak_used', None, None, ), # 8
    (9, TType.STRING, 'name', None, None, ), # 9
  )

  def __init__(self, committed=None, init=None, max=None, used=None, peak_committed=None, peak_init=None, peak_max=None, peak_used=None, name=None,):
    self.committed = committed
    self.init = init
    self.max = max
    self.used = used
    self.peak_committed = peak_committed
    self.peak_init = peak_init
    self.peak_max = peak_max
    self.peak_used = peak_used
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.committed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.init = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.max = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.used = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.peak_committed = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.peak_init = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.peak_max = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.peak_used = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TJvmMemoryPool')
    if self.committed is not None:
      oprot.writeFieldBegin('committed', TType.I64, 1)
      oprot.writeI64(self.committed)
      oprot.writeFieldEnd()
    if self.init is not None:
      oprot.writeFieldBegin('init', TType.I64, 2)
      oprot.writeI64(self.init)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I64, 3)
      oprot.writeI64(self.max)
      oprot.writeFieldEnd()
    if self.used is not None:
      oprot.writeFieldBegin('used', TType.I64, 4)
      oprot.writeI64(self.used)
      oprot.writeFieldEnd()
    if self.peak_committed is not None:
      oprot.writeFieldBegin('peak_committed', TType.I64, 5)
      oprot.writeI64(self.peak_committed)
      oprot.writeFieldEnd()
    if self.peak_init is not None:
      oprot.writeFieldBegin('peak_init', TType.I64, 6)
      oprot.writeI64(self.peak_init)
      oprot.writeFieldEnd()
    if self.peak_max is not None:
      oprot.writeFieldBegin('peak_max', TType.I64, 7)
      oprot.writeI64(self.peak_max)
      oprot.writeFieldEnd()
    if self.peak_used is not None:
      oprot.writeFieldBegin('peak_used', TType.I64, 8)
      oprot.writeI64(self.peak_used)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 9)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.committed is None:
      raise TProtocol.TProtocolException(message='Required field committed is unset!')
    if self.init is None:
      raise TProtocol.TProtocolException(message='Required field init is unset!')
    if self.max is None:
      raise TProtocol.TProtocolException(message='Required field max is unset!')
    if self.used is None:
      raise TProtocol.TProtocolException(message='Required field used is unset!')
    if self.peak_committed is None:
      raise TProtocol.TProtocolException(message='Required field peak_committed is unset!')
    if self.peak_init is None:
      raise TProtocol.TProtocolException(message='Required field peak_init is unset!')
    if self.peak_max is None:
      raise TProtocol.TProtocolException(message='Required field peak_max is unset!')
    if self.peak_used is None:
      raise TProtocol.TProtocolException(message='Required field peak_used is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmMetricsRequest(object):
  """
  Attributes:
   - get_all
   - memory_pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'get_all', None, None, ), # 1
    (2, TType.STRING, 'memory_pool', None, None, ), # 2
  )

  def __init__(self, get_all=None, memory_pool=None,):
    self.get_all = get_all
    self.memory_pool = memory_pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.get_all = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.memory_pool = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmMetricsRequest')
    if self.get_all is not None:
      oprot.writeFieldBegin('get_all', TType.BOOL, 1)
      oprot.writeBool(self.get_all)
      oprot.writeFieldEnd()
    if self.memory_pool is not None:
      oprot.writeFieldBegin('memory_pool', TType.STRING, 2)
      oprot.writeString(self.memory_pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.get_all is None:
      raise TProtocol.TProtocolException(message='Required field get_all is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetJvmMetricsResponse(object):
  """
  Attributes:
   - memory_pools
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'memory_pools', (TType.STRUCT,(TJvmMemoryPool, TJvmMemoryPool.thrift_spec)), None, ), # 1
  )

  def __init__(self, memory_pools=None,):
    self.memory_pools = memory_pools

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.memory_pools = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = TJvmMemoryPool()
            _elem154.read(iprot)
            self.memory_pools.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetJvmMetricsResponse')
    if self.memory_pools is not None:
      oprot.writeFieldBegin('memory_pools', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.memory_pools))
      for iter155 in self.memory_pools:
        iter155.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.memory_pools is None:
      raise TProtocol.TProtocolException(message='Required field memory_pools is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetHadoopConfigRequest(object):
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetHadoopConfigRequest')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetHadoopConfigResponse(object):
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetHadoopConfigResponse')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
