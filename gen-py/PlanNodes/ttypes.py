#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import CatalogObjects.ttypes
import ExecStats.ttypes
import Exprs.ttypes
import Types.ttypes
import ExternalDataSource.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TPlanNodeType(object):
  HDFS_SCAN_NODE = 0
  HBASE_SCAN_NODE = 1
  HASH_JOIN_NODE = 2
  AGGREGATION_NODE = 3
  SORT_NODE = 4
  EXCHANGE_NODE = 5
  UNION_NODE = 6
  SELECT_NODE = 7
  CROSS_JOIN_NODE = 8
  DATA_SOURCE_NODE = 9

  _VALUES_TO_NAMES = {
    0: "HDFS_SCAN_NODE",
    1: "HBASE_SCAN_NODE",
    2: "HASH_JOIN_NODE",
    3: "AGGREGATION_NODE",
    4: "SORT_NODE",
    5: "EXCHANGE_NODE",
    6: "UNION_NODE",
    7: "SELECT_NODE",
    8: "CROSS_JOIN_NODE",
    9: "DATA_SOURCE_NODE",
  }

  _NAMES_TO_VALUES = {
    "HDFS_SCAN_NODE": 0,
    "HBASE_SCAN_NODE": 1,
    "HASH_JOIN_NODE": 2,
    "AGGREGATION_NODE": 3,
    "SORT_NODE": 4,
    "EXCHANGE_NODE": 5,
    "UNION_NODE": 6,
    "SELECT_NODE": 7,
    "CROSS_JOIN_NODE": 8,
    "DATA_SOURCE_NODE": 9,
  }

class TExecNodePhase(object):
  PREPARE = 0
  OPEN = 1
  GETNEXT = 2
  CLOSE = 3
  INVALID = 4

  _VALUES_TO_NAMES = {
    0: "PREPARE",
    1: "OPEN",
    2: "GETNEXT",
    3: "CLOSE",
    4: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "PREPARE": 0,
    "OPEN": 1,
    "GETNEXT": 2,
    "CLOSE": 3,
    "INVALID": 4,
  }

class TDebugAction(object):
  WAIT = 0
  FAIL = 1

  _VALUES_TO_NAMES = {
    0: "WAIT",
    1: "FAIL",
  }

  _NAMES_TO_VALUES = {
    "WAIT": 0,
    "FAIL": 1,
  }

class TJoinOp(object):
  INNER_JOIN = 0
  LEFT_OUTER_JOIN = 1
  LEFT_SEMI_JOIN = 2
  RIGHT_OUTER_JOIN = 3
  FULL_OUTER_JOIN = 4
  CROSS_JOIN = 5

  _VALUES_TO_NAMES = {
    0: "INNER_JOIN",
    1: "LEFT_OUTER_JOIN",
    2: "LEFT_SEMI_JOIN",
    3: "RIGHT_OUTER_JOIN",
    4: "FULL_OUTER_JOIN",
    5: "CROSS_JOIN",
  }

  _NAMES_TO_VALUES = {
    "INNER_JOIN": 0,
    "LEFT_OUTER_JOIN": 1,
    "LEFT_SEMI_JOIN": 2,
    "RIGHT_OUTER_JOIN": 3,
    "FULL_OUTER_JOIN": 4,
    "CROSS_JOIN": 5,
  }


class THdfsFileSplit(object):
  """
  Attributes:
   - path
   - offset
   - length
   - partition_id
   - file_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.I64, 'offset', None, None, ), # 2
    (3, TType.I64, 'length', None, None, ), # 3
    (4, TType.I64, 'partition_id', None, None, ), # 4
    (5, TType.I64, 'file_length', None, None, ), # 5
  )

  def __init__(self, path=None, offset=None, length=None, partition_id=None, file_length=None,):
    self.path = path
    self.offset = offset
    self.length = length
    self.partition_id = partition_id
    self.file_length = file_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.partition_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.file_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileSplit')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 2)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 3)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.partition_id is not None:
      oprot.writeFieldBegin('partition_id', TType.I64, 4)
      oprot.writeI64(self.partition_id)
      oprot.writeFieldEnd()
    if self.file_length is not None:
      oprot.writeFieldBegin('file_length', TType.I64, 5)
      oprot.writeI64(self.file_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.path is None:
      raise TProtocol.TProtocolException(message='Required field path is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.length is None:
      raise TProtocol.TProtocolException(message='Required field length is unset!')
    if self.partition_id is None:
      raise TProtocol.TProtocolException(message='Required field partition_id is unset!')
    if self.file_length is None:
      raise TProtocol.TProtocolException(message='Required field file_length is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseKeyRange(object):
  """
  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'startKey', None, None, ), # 1
    (2, TType.STRING, 'stopKey', None, None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.startKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stopKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseKeyRange')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.STRING, 1)
      oprot.writeString(self.startKey)
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.STRING, 2)
      oprot.writeString(self.stopKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRange(object):
  """
  Attributes:
   - hdfs_file_split
   - hbase_key_range
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hdfs_file_split', (THdfsFileSplit, THdfsFileSplit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'hbase_key_range', (THBaseKeyRange, THBaseKeyRange.thrift_spec), None, ), # 2
  )

  def __init__(self, hdfs_file_split=None, hbase_key_range=None,):
    self.hdfs_file_split = hdfs_file_split
    self.hbase_key_range = hbase_key_range

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hdfs_file_split = THdfsFileSplit()
          self.hdfs_file_split.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.hbase_key_range = THBaseKeyRange()
          self.hbase_key_range.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRange')
    if self.hdfs_file_split is not None:
      oprot.writeFieldBegin('hdfs_file_split', TType.STRUCT, 1)
      self.hdfs_file_split.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_key_range is not None:
      oprot.writeFieldBegin('hbase_key_range', TType.STRUCT, 2)
      self.hbase_key_range.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsScanNode(object):
  """
  Attributes:
   - tuple_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
  )

  def __init__(self, tuple_id=None,):
    self.tuple_id = tuple_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDataSourceScanNode(object):
  """
  Attributes:
   - tuple_id
   - data_source
   - init_string
   - accepted_predicates
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.STRUCT, 'data_source', (CatalogObjects.ttypes.TDataSource, CatalogObjects.ttypes.TDataSource.thrift_spec), None, ), # 2
    (3, TType.STRING, 'init_string', None, None, ), # 3
    (4, TType.LIST, 'accepted_predicates', (TType.LIST,(TType.STRUCT,(ExternalDataSource.ttypes.TBinaryPredicate, ExternalDataSource.ttypes.TBinaryPredicate.thrift_spec))), None, ), # 4
  )

  def __init__(self, tuple_id=None, data_source=None, init_string=None, accepted_predicates=None,):
    self.tuple_id = tuple_id
    self.data_source = data_source
    self.init_string = init_string
    self.accepted_predicates = accepted_predicates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data_source = CatalogObjects.ttypes.TDataSource()
          self.data_source.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.init_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.accepted_predicates = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = []
            (_etype9, _size6) = iprot.readListBegin()
            for _i10 in xrange(_size6):
              _elem11 = ExternalDataSource.ttypes.TBinaryPredicate()
              _elem11.read(iprot)
              _elem5.append(_elem11)
            iprot.readListEnd()
            self.accepted_predicates.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDataSourceScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.data_source is not None:
      oprot.writeFieldBegin('data_source', TType.STRUCT, 2)
      self.data_source.write(oprot)
      oprot.writeFieldEnd()
    if self.init_string is not None:
      oprot.writeFieldBegin('init_string', TType.STRING, 3)
      oprot.writeString(self.init_string)
      oprot.writeFieldEnd()
    if self.accepted_predicates is not None:
      oprot.writeFieldBegin('accepted_predicates', TType.LIST, 4)
      oprot.writeListBegin(TType.LIST, len(self.accepted_predicates))
      for iter12 in self.accepted_predicates:
        oprot.writeListBegin(TType.STRUCT, len(iter12))
        for iter13 in iter12:
          iter13.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.data_source is None:
      raise TProtocol.TProtocolException(message='Required field data_source is unset!')
    if self.init_string is None:
      raise TProtocol.TProtocolException(message='Required field init_string is unset!')
    if self.accepted_predicates is None:
      raise TProtocol.TProtocolException(message='Required field accepted_predicates is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseFilter(object):
  """
  Attributes:
   - family
   - qualifier
   - op_ordinal
   - filter_constant
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.I32, 'op_ordinal', None, None, ), # 3
    (4, TType.STRING, 'filter_constant', None, None, ), # 4
  )

  def __init__(self, family=None, qualifier=None, op_ordinal=None, filter_constant=None,):
    self.family = family
    self.qualifier = qualifier
    self.op_ordinal = op_ordinal
    self.filter_constant = filter_constant

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.op_ordinal = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter_constant = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseFilter')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.op_ordinal is not None:
      oprot.writeFieldBegin('op_ordinal', TType.I32, 3)
      oprot.writeI32(self.op_ordinal)
      oprot.writeFieldEnd()
    if self.filter_constant is not None:
      oprot.writeFieldBegin('filter_constant', TType.STRING, 4)
      oprot.writeString(self.filter_constant)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.op_ordinal is None:
      raise TProtocol.TProtocolException(message='Required field op_ordinal is unset!')
    if self.filter_constant is None:
      raise TProtocol.TProtocolException(message='Required field filter_constant is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseScanNode(object):
  """
  Attributes:
   - tuple_id
   - table_name
   - filters
   - suggested_max_caching
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'filters', (TType.STRUCT,(THBaseFilter, THBaseFilter.thrift_spec)), None, ), # 3
    (4, TType.I32, 'suggested_max_caching', None, None, ), # 4
  )

  def __init__(self, tuple_id=None, table_name=None, filters=None, suggested_max_caching=None,):
    self.tuple_id = tuple_id
    self.table_name = table_name
    self.filters = filters
    self.suggested_max_caching = suggested_max_caching

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filters = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = THBaseFilter()
            _elem19.read(iprot)
            self.filters.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.suggested_max_caching = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.filters))
      for iter20 in self.filters:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.suggested_max_caching is not None:
      oprot.writeFieldBegin('suggested_max_caching', TType.I32, 4)
      oprot.writeI32(self.suggested_max_caching)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TEqJoinCondition(object):
  """
  Attributes:
   - left
   - right
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'left', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'right', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
  )

  def __init__(self, left=None, right=None,):
    self.left = left
    self.right = right

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.left = Exprs.ttypes.TExpr()
          self.left.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.right = Exprs.ttypes.TExpr()
          self.right.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TEqJoinCondition')
    if self.left is not None:
      oprot.writeFieldBegin('left', TType.STRUCT, 1)
      self.left.write(oprot)
      oprot.writeFieldEnd()
    if self.right is not None:
      oprot.writeFieldBegin('right', TType.STRUCT, 2)
      self.right.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.left is None:
      raise TProtocol.TProtocolException(message='Required field left is unset!')
    if self.right is None:
      raise TProtocol.TProtocolException(message='Required field right is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THashJoinNode(object):
  """
  Attributes:
   - join_op
   - eq_join_conjuncts
   - other_join_conjuncts
   - add_probe_filters
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'join_op', None, None, ), # 1
    (2, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT,(TEqJoinCondition, TEqJoinCondition.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'other_join_conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 3
    (4, TType.BOOL, 'add_probe_filters', None, None, ), # 4
  )

  def __init__(self, join_op=None, eq_join_conjuncts=None, other_join_conjuncts=None, add_probe_filters=None,):
    self.join_op = join_op
    self.eq_join_conjuncts = eq_join_conjuncts
    self.other_join_conjuncts = other_join_conjuncts
    self.add_probe_filters = add_probe_filters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.join_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.eq_join_conjuncts = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = TEqJoinCondition()
            _elem26.read(iprot)
            self.eq_join_conjuncts.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.other_join_conjuncts = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = Exprs.ttypes.TExpr()
            _elem32.read(iprot)
            self.other_join_conjuncts.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add_probe_filters = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THashJoinNode')
    if self.join_op is not None:
      oprot.writeFieldBegin('join_op', TType.I32, 1)
      oprot.writeI32(self.join_op)
      oprot.writeFieldEnd()
    if self.eq_join_conjuncts is not None:
      oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
      for iter33 in self.eq_join_conjuncts:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.other_join_conjuncts is not None:
      oprot.writeFieldBegin('other_join_conjuncts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.other_join_conjuncts))
      for iter34 in self.other_join_conjuncts:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.add_probe_filters is not None:
      oprot.writeFieldBegin('add_probe_filters', TType.BOOL, 4)
      oprot.writeBool(self.add_probe_filters)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.join_op is None:
      raise TProtocol.TProtocolException(message='Required field join_op is unset!')
    if self.eq_join_conjuncts is None:
      raise TProtocol.TProtocolException(message='Required field eq_join_conjuncts is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAggregationNode(object):
  """
  Attributes:
   - grouping_exprs
   - aggregate_functions
   - agg_tuple_id
   - need_finalize
   - is_merge
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'grouping_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'aggregate_functions', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 2
    (3, TType.I32, 'agg_tuple_id', None, None, ), # 3
    (4, TType.BOOL, 'need_finalize', None, None, ), # 4
    (5, TType.BOOL, 'is_merge', None, None, ), # 5
  )

  def __init__(self, grouping_exprs=None, aggregate_functions=None, agg_tuple_id=None, need_finalize=None, is_merge=None,):
    self.grouping_exprs = grouping_exprs
    self.aggregate_functions = aggregate_functions
    self.agg_tuple_id = agg_tuple_id
    self.need_finalize = need_finalize
    self.is_merge = is_merge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.grouping_exprs = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Exprs.ttypes.TExpr()
            _elem40.read(iprot)
            self.grouping_exprs.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.aggregate_functions = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = Exprs.ttypes.TExpr()
            _elem46.read(iprot)
            self.aggregate_functions.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.agg_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.need_finalize = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_merge = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAggregationNode')
    if self.grouping_exprs is not None:
      oprot.writeFieldBegin('grouping_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.grouping_exprs))
      for iter47 in self.grouping_exprs:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aggregate_functions is not None:
      oprot.writeFieldBegin('aggregate_functions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.aggregate_functions))
      for iter48 in self.aggregate_functions:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.agg_tuple_id is not None:
      oprot.writeFieldBegin('agg_tuple_id', TType.I32, 3)
      oprot.writeI32(self.agg_tuple_id)
      oprot.writeFieldEnd()
    if self.need_finalize is not None:
      oprot.writeFieldBegin('need_finalize', TType.BOOL, 4)
      oprot.writeBool(self.need_finalize)
      oprot.writeFieldEnd()
    if self.is_merge is not None:
      oprot.writeFieldBegin('is_merge', TType.BOOL, 5)
      oprot.writeBool(self.is_merge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aggregate_functions is None:
      raise TProtocol.TProtocolException(message='Required field aggregate_functions is unset!')
    if self.agg_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field agg_tuple_id is unset!')
    if self.need_finalize is None:
      raise TProtocol.TProtocolException(message='Required field need_finalize is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSortInfo(object):
  """
  Attributes:
   - ordering_exprs
   - is_asc_order
   - nulls_first
   - sort_tuple_slot_exprs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ordering_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'is_asc_order', (TType.BOOL,None), None, ), # 2
    (3, TType.LIST, 'nulls_first', (TType.BOOL,None), None, ), # 3
    (4, TType.LIST, 'sort_tuple_slot_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 4
  )

  def __init__(self, ordering_exprs=None, is_asc_order=None, nulls_first=None, sort_tuple_slot_exprs=None,):
    self.ordering_exprs = ordering_exprs
    self.is_asc_order = is_asc_order
    self.nulls_first = nulls_first
    self.sort_tuple_slot_exprs = sort_tuple_slot_exprs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ordering_exprs = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Exprs.ttypes.TExpr()
            _elem54.read(iprot)
            self.ordering_exprs.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.is_asc_order = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = iprot.readBool();
            self.is_asc_order.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.nulls_first = []
          (_etype64, _size61) = iprot.readListBegin()
          for _i65 in xrange(_size61):
            _elem66 = iprot.readBool();
            self.nulls_first.append(_elem66)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.sort_tuple_slot_exprs = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = Exprs.ttypes.TExpr()
            _elem72.read(iprot)
            self.sort_tuple_slot_exprs.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSortInfo')
    if self.ordering_exprs is not None:
      oprot.writeFieldBegin('ordering_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.ordering_exprs))
      for iter73 in self.ordering_exprs:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_asc_order is not None:
      oprot.writeFieldBegin('is_asc_order', TType.LIST, 2)
      oprot.writeListBegin(TType.BOOL, len(self.is_asc_order))
      for iter74 in self.is_asc_order:
        oprot.writeBool(iter74)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nulls_first is not None:
      oprot.writeFieldBegin('nulls_first', TType.LIST, 3)
      oprot.writeListBegin(TType.BOOL, len(self.nulls_first))
      for iter75 in self.nulls_first:
        oprot.writeBool(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sort_tuple_slot_exprs is not None:
      oprot.writeFieldBegin('sort_tuple_slot_exprs', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.sort_tuple_slot_exprs))
      for iter76 in self.sort_tuple_slot_exprs:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ordering_exprs is None:
      raise TProtocol.TProtocolException(message='Required field ordering_exprs is unset!')
    if self.is_asc_order is None:
      raise TProtocol.TProtocolException(message='Required field is_asc_order is unset!')
    if self.nulls_first is None:
      raise TProtocol.TProtocolException(message='Required field nulls_first is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSortNode(object):
  """
  Attributes:
   - sort_info
   - use_top_n
   - offset
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sort_info', (TSortInfo, TSortInfo.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'use_top_n', None, None, ), # 2
    (3, TType.I64, 'offset', None, None, ), # 3
  )

  def __init__(self, sort_info=None, use_top_n=None, offset=None,):
    self.sort_info = sort_info
    self.use_top_n = use_top_n
    self.offset = offset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sort_info = TSortInfo()
          self.sort_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.use_top_n = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSortNode')
    if self.sort_info is not None:
      oprot.writeFieldBegin('sort_info', TType.STRUCT, 1)
      self.sort_info.write(oprot)
      oprot.writeFieldEnd()
    if self.use_top_n is not None:
      oprot.writeFieldBegin('use_top_n', TType.BOOL, 2)
      oprot.writeBool(self.use_top_n)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 3)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sort_info is None:
      raise TProtocol.TProtocolException(message='Required field sort_info is unset!')
    if self.use_top_n is None:
      raise TProtocol.TProtocolException(message='Required field use_top_n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUnionNode(object):
  """
  Attributes:
   - tuple_id
   - result_expr_lists
   - const_expr_lists
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.LIST, 'result_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 2
    (3, TType.LIST, 'const_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 3
  )

  def __init__(self, tuple_id=None, result_expr_lists=None, const_expr_lists=None,):
    self.tuple_id = tuple_id
    self.result_expr_lists = result_expr_lists
    self.const_expr_lists = const_expr_lists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.result_expr_lists = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = []
            (_etype86, _size83) = iprot.readListBegin()
            for _i87 in xrange(_size83):
              _elem88 = Exprs.ttypes.TExpr()
              _elem88.read(iprot)
              _elem82.append(_elem88)
            iprot.readListEnd()
            self.result_expr_lists.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.const_expr_lists = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = []
            (_etype98, _size95) = iprot.readListBegin()
            for _i99 in xrange(_size95):
              _elem100 = Exprs.ttypes.TExpr()
              _elem100.read(iprot)
              _elem94.append(_elem100)
            iprot.readListEnd()
            self.const_expr_lists.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUnionNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.result_expr_lists is not None:
      oprot.writeFieldBegin('result_expr_lists', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.result_expr_lists))
      for iter101 in self.result_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter101))
        for iter102 in iter101:
          iter102.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.const_expr_lists is not None:
      oprot.writeFieldBegin('const_expr_lists', TType.LIST, 3)
      oprot.writeListBegin(TType.LIST, len(self.const_expr_lists))
      for iter103 in self.const_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter103))
        for iter104 in iter103:
          iter104.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.result_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field result_expr_lists is unset!')
    if self.const_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field const_expr_lists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExchangeNode(object):
  """
  Attributes:
   - input_row_tuples
   - sort_info
   - offset
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'input_row_tuples', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'sort_info', (TSortInfo, TSortInfo.thrift_spec), None, ), # 2
    (3, TType.I64, 'offset', None, None, ), # 3
  )

  def __init__(self, input_row_tuples=None, sort_info=None, offset=None,):
    self.input_row_tuples = input_row_tuples
    self.sort_info = sort_info
    self.offset = offset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.input_row_tuples = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readI32();
            self.input_row_tuples.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sort_info = TSortInfo()
          self.sort_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExchangeNode')
    if self.input_row_tuples is not None:
      oprot.writeFieldBegin('input_row_tuples', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.input_row_tuples))
      for iter111 in self.input_row_tuples:
        oprot.writeI32(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sort_info is not None:
      oprot.writeFieldBegin('sort_info', TType.STRUCT, 2)
      self.sort_info.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 3)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.input_row_tuples is None:
      raise TProtocol.TProtocolException(message='Required field input_row_tuples is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanNode(object):
  """
  Attributes:
   - node_id
   - node_type
   - num_children
   - limit
   - row_tuples
   - nullable_tuples
   - conjuncts
   - compact_data
   - hdfs_scan_node
   - hbase_scan_node
   - data_source_node
   - hash_join_node
   - agg_node
   - sort_node
   - union_node
   - exchange_node
   - label
   - label_detail
   - estimated_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'node_id', None, None, ), # 1
    (2, TType.I32, 'node_type', None, None, ), # 2
    (3, TType.I32, 'num_children', None, None, ), # 3
    (4, TType.I64, 'limit', None, None, ), # 4
    (5, TType.LIST, 'row_tuples', (TType.I32,None), None, ), # 5
    (6, TType.LIST, 'nullable_tuples', (TType.BOOL,None), None, ), # 6
    (7, TType.LIST, 'conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'compact_data', None, None, ), # 8
    (9, TType.STRUCT, 'hdfs_scan_node', (THdfsScanNode, THdfsScanNode.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'hbase_scan_node', (THBaseScanNode, THBaseScanNode.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'hash_join_node', (THashJoinNode, THashJoinNode.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'agg_node', (TAggregationNode, TAggregationNode.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'sort_node', (TSortNode, TSortNode.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'union_node', (TUnionNode, TUnionNode.thrift_spec), None, ), # 14
    (15, TType.STRUCT, 'exchange_node', (TExchangeNode, TExchangeNode.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'data_source_node', (TDataSourceScanNode, TDataSourceScanNode.thrift_spec), None, ), # 16
    (17, TType.STRING, 'label', None, None, ), # 17
    (18, TType.STRING, 'label_detail', None, None, ), # 18
    (19, TType.STRUCT, 'estimated_stats', (ExecStats.ttypes.TExecStats, ExecStats.ttypes.TExecStats.thrift_spec), None, ), # 19
  )

  def __init__(self, node_id=None, node_type=None, num_children=None, limit=None, row_tuples=None, nullable_tuples=None, conjuncts=None, compact_data=None, hdfs_scan_node=None, hbase_scan_node=None, data_source_node=None, hash_join_node=None, agg_node=None, sort_node=None, union_node=None, exchange_node=None, label=None, label_detail=None, estimated_stats=None,):
    self.node_id = node_id
    self.node_type = node_type
    self.num_children = num_children
    self.limit = limit
    self.row_tuples = row_tuples
    self.nullable_tuples = nullable_tuples
    self.conjuncts = conjuncts
    self.compact_data = compact_data
    self.hdfs_scan_node = hdfs_scan_node
    self.hbase_scan_node = hbase_scan_node
    self.data_source_node = data_source_node
    self.hash_join_node = hash_join_node
    self.agg_node = agg_node
    self.sort_node = sort_node
    self.union_node = union_node
    self.exchange_node = exchange_node
    self.label = label
    self.label_detail = label_detail
    self.estimated_stats = estimated_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.node_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_children = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.row_tuples = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = iprot.readI32();
            self.row_tuples.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.nullable_tuples = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readBool();
            self.nullable_tuples.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.conjuncts = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = Exprs.ttypes.TExpr()
            _elem129.read(iprot)
            self.conjuncts.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.compact_data = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.hdfs_scan_node = THdfsScanNode()
          self.hdfs_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.hbase_scan_node = THBaseScanNode()
          self.hbase_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.data_source_node = TDataSourceScanNode()
          self.data_source_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.hash_join_node = THashJoinNode()
          self.hash_join_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.agg_node = TAggregationNode()
          self.agg_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.sort_node = TSortNode()
          self.sort_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.union_node = TUnionNode()
          self.union_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.exchange_node = TExchangeNode()
          self.exchange_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.label = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.label_detail = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.estimated_stats = ExecStats.ttypes.TExecStats()
          self.estimated_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanNode')
    if self.node_id is not None:
      oprot.writeFieldBegin('node_id', TType.I32, 1)
      oprot.writeI32(self.node_id)
      oprot.writeFieldEnd()
    if self.node_type is not None:
      oprot.writeFieldBegin('node_type', TType.I32, 2)
      oprot.writeI32(self.node_type)
      oprot.writeFieldEnd()
    if self.num_children is not None:
      oprot.writeFieldBegin('num_children', TType.I32, 3)
      oprot.writeI32(self.num_children)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.row_tuples is not None:
      oprot.writeFieldBegin('row_tuples', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.row_tuples))
      for iter130 in self.row_tuples:
        oprot.writeI32(iter130)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullable_tuples is not None:
      oprot.writeFieldBegin('nullable_tuples', TType.LIST, 6)
      oprot.writeListBegin(TType.BOOL, len(self.nullable_tuples))
      for iter131 in self.nullable_tuples:
        oprot.writeBool(iter131)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.conjuncts is not None:
      oprot.writeFieldBegin('conjuncts', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.conjuncts))
      for iter132 in self.conjuncts:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.compact_data is not None:
      oprot.writeFieldBegin('compact_data', TType.BOOL, 8)
      oprot.writeBool(self.compact_data)
      oprot.writeFieldEnd()
    if self.hdfs_scan_node is not None:
      oprot.writeFieldBegin('hdfs_scan_node', TType.STRUCT, 9)
      self.hdfs_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_scan_node is not None:
      oprot.writeFieldBegin('hbase_scan_node', TType.STRUCT, 10)
      self.hbase_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hash_join_node is not None:
      oprot.writeFieldBegin('hash_join_node', TType.STRUCT, 11)
      self.hash_join_node.write(oprot)
      oprot.writeFieldEnd()
    if self.agg_node is not None:
      oprot.writeFieldBegin('agg_node', TType.STRUCT, 12)
      self.agg_node.write(oprot)
      oprot.writeFieldEnd()
    if self.sort_node is not None:
      oprot.writeFieldBegin('sort_node', TType.STRUCT, 13)
      self.sort_node.write(oprot)
      oprot.writeFieldEnd()
    if self.union_node is not None:
      oprot.writeFieldBegin('union_node', TType.STRUCT, 14)
      self.union_node.write(oprot)
      oprot.writeFieldEnd()
    if self.exchange_node is not None:
      oprot.writeFieldBegin('exchange_node', TType.STRUCT, 15)
      self.exchange_node.write(oprot)
      oprot.writeFieldEnd()
    if self.data_source_node is not None:
      oprot.writeFieldBegin('data_source_node', TType.STRUCT, 16)
      self.data_source_node.write(oprot)
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRING, 17)
      oprot.writeString(self.label)
      oprot.writeFieldEnd()
    if self.label_detail is not None:
      oprot.writeFieldBegin('label_detail', TType.STRING, 18)
      oprot.writeString(self.label_detail)
      oprot.writeFieldEnd()
    if self.estimated_stats is not None:
      oprot.writeFieldBegin('estimated_stats', TType.STRUCT, 19)
      self.estimated_stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.node_id is None:
      raise TProtocol.TProtocolException(message='Required field node_id is unset!')
    if self.node_type is None:
      raise TProtocol.TProtocolException(message='Required field node_type is unset!')
    if self.num_children is None:
      raise TProtocol.TProtocolException(message='Required field num_children is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    if self.row_tuples is None:
      raise TProtocol.TProtocolException(message='Required field row_tuples is unset!')
    if self.nullable_tuples is None:
      raise TProtocol.TProtocolException(message='Required field nullable_tuples is unset!')
    if self.compact_data is None:
      raise TProtocol.TProtocolException(message='Required field compact_data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlan(object):
  """
  Attributes:
   - nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT,(TPlanNode, TPlanNode.thrift_spec)), None, ), # 1
  )

  def __init__(self, nodes=None,):
    self.nodes = nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = TPlanNode()
            _elem138.read(iprot)
            self.nodes.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlan')
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter139 in self.nodes:
        iter139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nodes is None:
      raise TProtocol.TProtocolException(message='Required field nodes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
